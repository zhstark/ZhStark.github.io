<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小豪&#39;s blog</title>
  
  <subtitle>逢山开道，遇水搭桥</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhstark.com/"/>
  <updated>2020-11-22T01:15:39.045Z</updated>
  <id>http://zhstark.com/</id>
  
  <author>
    <name>Hao Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>存储型XSS攻击与防御</title>
    <link href="http://zhstark.com/2020/11/21/%E5%AD%98%E5%82%A8%E5%9E%8BXSS%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1/"/>
    <id>http://zhstark.com/2020/11/21/存储型XSS攻击与防御/</id>
    <published>2020-11-22T01:14:49.000Z</published>
    <updated>2020-11-22T01:15:39.045Z</updated>
    
    <content type="html"><![CDATA[<p>工作中网页要添加支持富文本功能，我写的 tech spec 讲富文本直接导出相应的 html format，后端直接存储 html。组里大佬敏锐的提出了直接使用 HTML 的安全隐患。</p><a id="more"></a><blockquote><p>Storing HTML would make me nervous – there are many potential attack vectors when re-displaying that content on the webpage (especially if you combine that with another ongoing discussion about user impersonation!). We’d probably want to tread lightly here and sanitize the HTML with a whitelist of elements before displaying it back out.</p></blockquote><p>回头自己搜了一下，原来他所担忧的是可能会被 XSS 攻击。</p><h2 id="什么是-XSS-攻击"><a href="#什么是-XSS-攻击" class="headerlink" title="什么是 XSS 攻击"></a>什么是 XSS 攻击</h2><p>XSS 全称Cross Site Script，叫做「跨站脚本攻击」，是指用户注入恶意的代码，如果浏览器和服务器都没有对该输入进行过滤，导致用户注入的脚本嵌入到了页面中。由于浏览器无法识别这些恶意代码正常解析执行，攻击者的恶意操作被成功执行，比如可以获取用户的cookie数据然后发送给自己或者冒充正常用户向被攻击的服务器发送请求。举个简单的例子，用户直接在富文本里写 js 脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;js bad code...&lt;/script&gt;</div></pre></td></tr></table></figure><p>由于没有过滤，该文本内容会由后端直接返回到其他用户浏览器，那么这段文本可能就不是以文本方式出现，而是被浏览器误以为是要去执行的一段代码，这样就是被攻击了。</p><h2 id="防范存储型-XSS-攻击"><a href="#防范存储型-XSS-攻击" class="headerlink" title="防范存储型 XSS 攻击"></a>防范存储型 XSS 攻击</h2><p>防范 XSS 攻击的奥义在于永远不要相信用户的输入。</p><p>先来看看存储型 XSS 的攻击步骤：</p><p>1.攻击者将恶意代码提交到目标网站的数据库中。<br>2.用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。<br>3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。<br>4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</p><p>XSS 过滤主要有两种模式：黑名单和白名单。</p><ul><li>基于黑名单的 XSS 过滤，将转义或移除黑名单中的标签和属性。</li><li>基于白名单的 XSS 过滤，仅允许白名单中的标签和属性存在，其他全部转义或移除。</li></ul><p>由于使用黑名单可能会有漏网之鱼存在，一般多是采用白名单。</p><p>方法也看起来很简单：要求用户仅能输入指定、有限的标签和属性。前端可以通过富文本编辑器配置，仅显示指定标签，提升用用户体验。后端不能直接信任前端数据，需要基于白名单再次过滤。这样可以保证，入库的数据都是可信任的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中网页要添加支持富文本功能，我写的 tech spec 讲富文本直接导出相应的 html format，后端直接存储 html。组里大佬敏锐的提出了直接使用 HTML 的安全隐患。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="技术" scheme="http://zhstark.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>自建shadowsocks翻墙服务</title>
    <link href="http://zhstark.com/2020/03/12/%E8%87%AA%E5%BB%BAshadowsocks%E7%BF%BB%E5%A2%99%E6%9C%8D%E5%8A%A1/"/>
    <id>http://zhstark.com/2020/03/12/自建shadowsocks翻墙服务/</id>
    <published>2020-03-13T05:51:26.000Z</published>
    <updated>2020-03-14T03:09:38.474Z</updated>
    
    <content type="html"><![CDATA[<p>Google Cloud 一年免费，不用白不用，本来是想用来做个微信机器人的，但是在登录的时候发现微信把 web 端关了，没有接口获取数据，直接流产。就先用来搭个翻墙服务器吧，以后回国用。</p><a id="more"></a><h2 id="一-安装"><a href="#一-安装" class="headerlink" title="一 安装"></a>一 安装</h2><p>我这里是 CentOS 系统</p><p>可以先进入 root 用户，这样就不用输入 <code>sudo</code> 了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo yum install python-pip</div><div class="line">sudo yum install python-setuptools &amp;&amp; easy_install pip</div><div class="line">sudo pip install shadowsocks</div></pre></td></tr></table></figure><h2 id="二-配置"><a href="#二-配置" class="headerlink" title="二 配置"></a>二 配置</h2><p><code>sudo vi /etc/shadowsocks.json</code></p><p>输入下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;server&quot;: &quot;my_server_ip&quot;, // 这里输入本机的 IP 地址</div><div class="line">    &quot;server_port&quot;: 8388, // 为了安全，可修改为大于 1024 的数字</div><div class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</div><div class="line">    &quot;local_port&quot;: 1080, // 为了安全，可修改为大于 1024 的数字</div><div class="line">    &quot;password&quot;: &quot;mypassword&quot;, // 设置一个密码</div><div class="line">    &quot;timeout&quot;: 300,</div><div class="line">    &quot;method&quot;: &quot;aes-256-cfb&quot;,</div><div class="line">    &quot;fast_open&quot;: false</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="三-qids"><a href="#三-qids" class="headerlink" title="三 qids"></a>三 qids</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssserve -c /etc/shadowsocks.json -d start</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Google Cloud 一年免费，不用白不用，本来是想用来做个微信机器人的，但是在登录的时候发现微信把 web 端关了，没有接口获取数据，直接流产。就先用来搭个翻墙服务器吧，以后回国用。&lt;/p&gt;
    
    </summary>
    
      <category term="记录" scheme="http://zhstark.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="tech" scheme="http://zhstark.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记</title>
    <link href="http://zhstark.com/2019/11/18/Java%E7%AC%94%E8%AE%B0/"/>
    <id>http://zhstark.com/2019/11/18/Java笔记/</id>
    <published>2019-11-18T23:50:05.000Z</published>
    <updated>2020-08-04T21:50:22.379Z</updated>
    
    <content type="html"><![CDATA[<p>刷题过程中常用的一些 Java 的方法、数据结构等</p><a id="more"></a><p>Java 中的数组初始值都为零</p><p>long int 强制类型转换<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> a=<span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> b=(<span class="keyword">int</span>) a;</div></pre></td></tr></table></figure></p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合包括两个基本接口：<code>Collection</code>和<code>Map</code>，</p><p>所有实现<code>Collection</code>的类都要有下面的方法，这些类可以使用<code>for each</code>的方法来遍历。如果要用迭代器遍历，则是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Collections&lt;String&gt; c=...;</div><div class="line">Iterator&lt;String&gt; it=c.iterator();</div><div class="line"><span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">String e=it.next();</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span></span>;</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span></span></div><div class="line"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; from)</span></div><div class="line"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object obj)</span>;</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;<span class="comment">//从这个集合中删除所有与 other 集合中的元素不同的元素。如果这个调用改变了集合，返回 true</span></div><div class="line">Object[] toArray();</div><div class="line">&lt;T&gt; T[] toArray(T[] arrayToFill);</div></pre></td></tr></table></figure><h2 id="键盘读取数据："><a href="#键盘读取数据：" class="headerlink" title="键盘读取数据："></a>键盘读取数据：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in); </div><div class="line"><span class="keyword">int</span> n = s.nextInt(); <span class="comment">// 或者其他数据类型</span></div></pre></td></tr></table></figure><h2 id="随机数的写法："><a href="#随机数的写法：" class="headerlink" title="随机数的写法："></a>随机数的写法：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Math.random(); <span class="comment">// [0,1) double类型</span></div></pre></td></tr></table></figure><h2 id="Integer-Max-min"><a href="#Integer-Max-min" class="headerlink" title="Integer Max, min"></a>Integer Max, min</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer.MAX_VALUE;</div><div class="line">Integer.MIN_VALUE;</div></pre></td></tr></table></figure><h2 id="Char"><a href="#Char" class="headerlink" title="Char"></a>Char</h2><p>大小写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> Character.toLowerCase(<span class="keyword">char</span> c)</div><div class="line"><span class="keyword">char</span> Character.toUpperCase(<span class="keyword">char</span> c)</div></pre></td></tr></table></figure></p><p>判断类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> Character.isLetterOrDigit(<span class="keyword">char</span> c)</div><div class="line"><span class="keyword">boolean</span> Character.isLetter(<span class="keyword">char</span> c)</div><div class="line"><span class="keyword">boolean</span> Character.isDigit(<span class="keyword">char</span> c)</div><div class="line"><span class="keyword">boolean</span> Character.isLowerCase(<span class="keyword">char</span> c)</div><div class="line"><span class="keyword">boolean</span> Character.isUpperCase(<span class="keyword">char</span> c)</div><div class="line"><span class="keyword">char</span> Character.toLowerCase(<span class="keyword">char</span> c)</div><div class="line"><span class="keyword">char</span> Character.toUpperCase(<span class="keyword">char</span> c)</div></pre></td></tr></table></figure><h2 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">int length()</div><div class="line"></div><div class="line">int indexOf(char ch)</div><div class="line"></div><div class="line">int indexOf(String str)</div><div class="line">int lastIndexOf(int ch)</div><div class="line">int lastIndexOf(String str)</div><div class="line"></div><div class="line">String substring(int begin)</div><div class="line">String substring(int begin, int end)</div><div class="line">boolean equals(Object obj)</div><div class="line"></div><div class="line">char charAt(int index)</div><div class="line">String[] split(String regex, int limit)</div><div class="line">例如String[] temp = s.split(&quot;\\s+&quot;);</div><div class="line"></div><div class="line">s.trim(); //The java lang.string.trim()is a built-in function that eliminates leading and trailing spaces.</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">word.toCharArray()<span class="comment">// 变成 char[], 可以用 for each 循环</span></div><div class="line">word.toLowerCase();</div><div class="line">word.toUpperCase();</div></pre></td></tr></table></figure><p>比较大小：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Str1.compareTo(Str2)</div><div class="line"><span class="comment">// &lt;0: s1&lt;s2</span></div><div class="line"><span class="comment">// =0: s1=s2</span></div><div class="line"><span class="comment">// &gt;0: s1&gt;s2</span></div></pre></td></tr></table></figure></p><h3 id="String-to-int-long"><a href="#String-to-int-long" class="headerlink" title="String to int/long"></a>String to int/long</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Integer.parseInt()</span></div><div class="line">String number = <span class="string">"10"</span>;</div><div class="line"><span class="keyword">int</span> result = Integer.parseInt(number);</div><div class="line"></div><div class="line"><span class="comment">//Long.parseLong(String)</span></div></pre></td></tr></table></figure><p>Integer to String<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s=Integer.toString(<span class="number">1</span>);</div></pre></td></tr></table></figure></p><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder:"></a>StringBuilder:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">StringBuilder <span class="title">append</span><span class="params">(String str)</span></span></div><div class="line">StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, String str)</span></div><div class="line">StringBuilder <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></div><div class="line">StringBuilder <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span></div><div class="line"><span class="title">SetCharAt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> c)</span>;</div><div class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span></div><div class="line"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></div></pre></td></tr></table></figure><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList:"></a>ArrayList:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">add(Object)</div><div class="line">add(index, Object)</div><div class="line"><span class="function">Object <span class="title">remove</span><span class="params">(pos)</span></span></div><div class="line">Object <span class="title">get</span><span class="params">(pos)</span></div><div class="line"><span class="title">size</span><span class="params">()</span></div><div class="line"><span class="title">set</span><span class="params">(pos, Object)</span></div></pre></td></tr></table></figure><p>排序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.sort(list);</div></pre></td></tr></table></figure></p><p>交换<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.swap(list, index1, index2)</div></pre></td></tr></table></figure></p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList:"></a>LinkedList:</h2><p>Java 中的 LinkedList 是双向链表<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">add(Object)</div><div class="line"><span class="function">Object <span class="title">remove</span><span class="params">()</span></span></div><div class="line"><span class="title">size</span><span class="params">()</span></div></pre></td></tr></table></figure></p><p>一件很神奇的事是：Queue\<object\> queue = new LinkedList\&lt;>(); 因为Queue接口是用链表实现的</object\></p><h2 id="Queue-amp-Deque"><a href="#Queue-amp-Deque" class="headerlink" title="Queue &amp; Deque"></a>Queue &amp; Deque</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Queue&lt;String&gt; queue=<span class="keyword">new</span> LinkedList&lt;String&gt;();</div><div class="line"></div><div class="line">queue.offer(<span class="string">"a"</span>); </div><div class="line">Or queue.add(<span class="string">"a"</span>);</div><div class="line"></div><div class="line">queue.offer(<span class="string">"b"</span>);</div><div class="line"><span class="keyword">for</span>(String q:queue)&#123;&#125;</div><div class="line"></div><div class="line">String p=queue.poll() <span class="comment">//返回第一个元素，并在队列中删除</span></div><div class="line">Or p=queue.remove();</div><div class="line"></div><div class="line">String p2=queue.element();<span class="comment">//返回第一个元素</span></div><div class="line">String p3=queue.peek();<span class="comment">// 返回第一个元素</span></div><div class="line"><span class="keyword">int</span> a=queue.size();</div><div class="line">q.isEmpty()</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Deque&lt;Integer&gt; dq=<span class="keyword">new</span> LinkedList();</div><div class="line">dq.addFirst(<span class="number">1</span>);</div><div class="line">dq.addLast(<span class="number">2</span>);</div><div class="line">dq.offerFirst(<span class="number">1</span>);</div><div class="line">dq.offerLast(<span class="number">2</span>);</div><div class="line"></div><div class="line">dq.removeFirst();</div><div class="line">dq.removeLast();</div><div class="line">dq.pollFirst();</div><div class="line">dq.pollLast();</div><div class="line"></div><div class="line">dq.getFirst();</div><div class="line">dq.getLast();</div><div class="line">dq.peekFirst();</div><div class="line">dq.peekLast();</div></pre></td></tr></table></figure><h2 id="HashSet-TreeSet"><a href="#HashSet-TreeSet" class="headerlink" title="HashSet TreeSet"></a>HashSet TreeSet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">add, remove, removeAll(obj), contains(obj), isEmpty, <span class="function">removeAll</span></div><div class="line"><span class="title">for</span><span class="params">(<span class="keyword">char</span> c: set)</span>&#123;&#125;</div></pre></td></tr></table></figure><h2 id="HashMap-TreeMap"><a href="#HashMap-TreeMap" class="headerlink" title="HashMap TreeMap"></a>HashMap TreeMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function">Object <span class="title">get</span><span class="params">(key)</span></span>;</div><div class="line"><span class="function">Object <span class="title">getOrDefault</span><span class="params">(key, defaultValue)</span></span>;</div><div class="line">put(key, value);</div><div class="line">putAll(Map&lt;&gt; map);</div><div class="line">remove(key);</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(key, value)</span></span>;</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(key)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//枚举所有 key</span></div><div class="line">Set&lt;String&gt; keys=map.keySet();</div><div class="line"><span class="keyword">for</span>(String key: keys)&#123;...&#125;</div><div class="line"></div><div class="line"><span class="comment">//同时看所有 key 和值</span></div><div class="line">Set&lt;Entry&lt;String, String&gt;&gt; entrySet=animal.entrySet(); </div><div class="line"><span class="keyword">for</span>(Entry&lt;String, String&gt; entry:entrySet) </div><div class="line">System.out.println(entry.getKey() + entry.getValue());</div><div class="line"><span class="comment">//大小</span></div><div class="line">map.size();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c: degree.keySet())&#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack:"></a>Stack:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></div><div class="line">Object <span class="title">peek</span><span class="params">()</span></div><div class="line">Object <span class="title">pop</span><span class="params">()</span></div><div class="line"><span class="title">push</span><span class="params">(Object)</span></div></pre></td></tr></table></figure><h2 id="我就在Hard题里见过的ArrayDeque"><a href="#我就在Hard题里见过的ArrayDeque" class="headerlink" title="我就在Hard题里见过的ArrayDeque"></a>我就在Hard题里见过的ArrayDeque</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">deq.addLast(Object)</div><div class="line"><span class="keyword">boolean</span> deq.isEmpty()</div><div class="line">Object deq.getFirst()</div><div class="line">deq.removeFirst()</div><div class="line">Object deq.getLast()</div><div class="line">deq.removeLast()</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String s = Arrays.toString(一个数组)</div><div class="line">List s = Arrays.asList(一个数组)</div><div class="line">Arrays.sort(一个数组);</div><div class="line">Math.abs(<span class="keyword">int</span>);</div></pre></td></tr></table></figure><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">lambda表达式，以LC973为例</div><div class="line"><span class="comment">//这里注意：要带匿名表达式，`&lt;&gt;`不能省略！！！！</span></div><div class="line">PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((p1, p2)-&gt; (p2[<span class="number">0</span>] * p2[<span class="number">0</span>] + p2[<span class="number">1</span>] * p2[<span class="number">1</span>] - p1[<span class="number">0</span>] * p1[<span class="number">0</span>] - p1[<span class="number">1</span>] * p1[<span class="number">1</span>]));</div><div class="line">add(Object)</div><div class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span></div><div class="line">E <span class="title">poll</span><span class="params">()</span></div><div class="line">E <span class="title">remove</span><span class="params">()</span>;</div></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong> 这里是指 形如 int[] 的</strong><br>快速初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Arrays.fill(a, <span class="number">1</span>);</div></pre></td></tr></table></figure><p>排序，是更改原数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Arrays.sort(A);</div></pre></td></tr></table></figure></p><p>拷贝（深拷贝）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">System.arraycopy(src, srcPos, dest, destPos, length);</div><div class="line"><span class="keyword">int</span>[] a2=a1.clone() <span class="comment">//深拷贝</span></div><div class="line"><span class="keyword">int</span>[] a3=Arrays.copyOf(a1, <span class="number">3</span>)<span class="comment">// (原数组，拷贝的个数)</span></div></pre></td></tr></table></figure></p><h2 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a>Pair</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Pair p1 = <span class="keyword">new</span> Pair(<span class="number">3</span>,<span class="number">4</span>); </div><div class="line">Pair p2 = <span class="keyword">new</span> Pair(<span class="number">3</span>,<span class="number">4</span>); </div><div class="line">Pair p3 = <span class="keyword">new</span> Pair(<span class="number">4</span>,<span class="number">4</span>); </div><div class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span> <span class="comment">// This method will return the String representation of the Pair.</span></span></div><div class="line">K <span class="title">getKey</span><span class="params">()</span> <span class="comment">// It returns key for the pair.</span></div><div class="line">V <span class="title">getValue</span><span class="params">()</span> <span class="comment">// It returns value for the pair.</span></div><div class="line"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">// Generate a hash code for the Pair.</span></div></pre></td></tr></table></figure><h2 id="Comparator-接口"><a href="#Comparator-接口" class="headerlink" title="Comparator 接口"></a>Comparator 接口</h2><p>比较器是实现了 Comparator 接口的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T first, T second)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>比如要比较字符串的长度，可以定义一个实现了这个接口的类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthComparator</span> <span class="title">implement</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compara</span><span class="params">(String first, String second)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> first.length()-second.length();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>具体使用时，需要建立一个实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;String&gt; comp=<span class="keyword">new</span> LengthComparator();</div><div class="line">Arrays.sort(list, comp);</div></pre></td></tr></table></figure></p><p><strong>也可以声明与实例放一块</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PriorityQueue&lt;ListNode&gt; q=<span class="keyword">new</span> PriorityQueue(lists.length, <span class="keyword">new</span> Comparator&lt;ListNode&gt;()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode t1, ListNode t2)</span></span>&#123;</div><div class="line">                <span class="keyword">return</span> t1.val-t2.val;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>对 Collection（List等）排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果list是 5 7 2 6 8 1 4</span></div><div class="line"><span class="comment">//1、升序：</span></div><div class="line">Collections.sort(list) <span class="comment">//list： 1 2 4 5 6 7 8</span></div><div class="line"><span class="comment">//2、降序：</span></div><div class="line">Collections.sort(list，Collections.reverseOrder())<span class="comment">//list:8 7 6 5 4 2 1</span></div><div class="line"><span class="comment">//3、逆序；</span></div><div class="line">Collections.reverse(list)<span class="comment">//list：4 1 8 6 2 7 5</span></div></pre></td></tr></table></figure><p>对普通数组排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] a=&#123;<span class="number">5</span> <span class="number">7</span> <span class="number">2</span> <span class="number">6</span> <span class="number">8</span> <span class="number">1</span> <span class="number">4</span>&#125;</div><div class="line"><span class="comment">//1、升序：</span></div><div class="line">Arrays.sort(a)<span class="comment">//a： 1 2 4 5 6 7 8</span></div><div class="line"><span class="comment">//2、降序：</span></div><div class="line"><span class="comment">//    </span></div><div class="line">注意！！！！：这里是 Integer[] a </div><div class="line">Arrays.sort(a，Collections.reverseOrder())<span class="comment">//a： 8 7 6 5 4 2 1</span></div></pre></td></tr></table></figure><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h3><p>用 <code>readLine()</code> 一次读取一个文本行，如果读到行尾了就返回 null</p><p>注意用<code>BufferedReader</code> 要处理异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printByFileReaderLine</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException</span></div><div class="line">&#123;</div><div class="line">    BufferedReader reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filePath));</div><div class="line">    <span class="keyword">if</span>(!reader.ready())&#123;</div><div class="line">        System.out.println(<span class="string">"文件流暂时无法读取"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> size=<span class="number">0</span>;</div><div class="line">    String line;</div><div class="line">    <span class="keyword">while</span>((line=reader.readLine())!=<span class="keyword">null</span>)</div><div class="line">    &#123;</div><div class="line">        System.out.print(line+<span class="string">"\n"</span>);</div><div class="line">    &#125;</div><div class="line">    reader.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>需要注意的是：<code>reader.readLine()</code>方法返回的一行字符中不包含换行符,所以输出的时候要自己加上换行符。</p><p><strong> 关于乱码问题</strong></p><p>使用包装<code>InputStreamReader</code>的<code>BufferedReader</code>读取文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">String file = <span class="string">"utf8.txt"</span>;</div><div class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(</div><div class="line">        <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(file), <span class="string">"utf-8"</span>));</div><div class="line"><span class="keyword">char</span>[] cbuf=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</div><div class="line"><span class="keyword">int</span> size;</div><div class="line"><span class="keyword">while</span>((size=reader.read(cbuf, <span class="number">0</span>, cbuf.length))!=-<span class="number">1</span>)&#123;</div><div class="line">    System.out.println(<span class="keyword">new</span> String(cbuf,<span class="number">0</span>,size));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">File file = <span class="keyword">new</span> File(<span class="string">"Hello1.txt"</span>);</div><div class="line"><span class="comment">// 创建文件</span></div><div class="line">file.createNewFile();</div><div class="line"><span class="comment">// creates a FileWriter Object</span></div><div class="line">BufferedWriter writer =<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file));</div><div class="line"><span class="comment">// 向文件写入内容</span></div><div class="line">writer.write(<span class="string">"This\n is\n an\n example\n"</span>);</div><div class="line">writer.newLine();<span class="comment">//写换行符</span></div><div class="line">writer.flush();</div><div class="line">writer.close();</div></pre></td></tr></table></figure><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul><li>Java 虚拟机将从指定类中的 main 方法开始执行</li><li>Java 的所有函数都是属于某个类的方法</li><li>Java 中没有无符号形式的 int、double、short 等</li><li>char 类型用单引号</li><li>声明一个变量之后，必须用赋值语句对变量进行显示初始化，千万不要使用未初始化的变量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题过程中常用的一些 Java 的方法、数据结构等&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://zhstark.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的length,length()和size()</title>
    <link href="http://zhstark.com/2019/08/17/Java%E4%B8%AD%E7%9A%84length-length-%E5%92%8Csize/"/>
    <id>http://zhstark.com/2019/08/17/Java中的length-length-和size/</id>
    <published>2019-08-17T22:55:01.000Z</published>
    <updated>2019-08-17T12:27:35.961Z</updated>
    
    <content type="html"><![CDATA[<p>Java 中判断一个元素的长度一会 size()，一会 length，一会 length()，简直有毒。如何判断用哪个呢？选择这些方法时有什么规律吗？</p><a id="more"></a><p>1 java中的length属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了length这个属性.</p><p>2 java中的length()方法是针对字符串String说的,如果想看这个字符串的长度则用到length()这个方法.</p><p>3.java中的size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 中判断一个元素的长度一会 size()，一会 length，一会 length()，简直有毒。如何判断用哪个呢？选择这些方法时有什么规律吗？&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://zhstark.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>springboot连接操作mysql</title>
    <link href="http://zhstark.com/2019/08/12/springboot%E9%93%BE%E6%8E%A5mysql/"/>
    <id>http://zhstark.com/2019/08/12/springboot链接mysql/</id>
    <published>2019-08-12T23:29:58.000Z</published>
    <updated>2019-08-15T08:14:33.844Z</updated>
    
    <content type="html"><![CDATA[<p>实习过程中需要自己起一个 Springboot 项目并要与 MySQL 交互，第二次更新项目内容时所作记录以防遗忘。</p><p>基本的 SpringBoot 知识与 MySQL 都不会介绍。</p><a id="more"></a><h2 id="Maven-配置"><a href="#Maven-配置" class="headerlink" title="Maven 配置"></a>Maven 配置</h2><p><em>pom.xml</em></p><p>这里需要添加配置 JPA 和 MySQL connector。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gs-mysql-data<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- JPA Data (We are going to use Repositories, Entities, Hibernate, etc...) --&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- Use MySQL Connector-J --&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="配置-application-properties"><a href="#配置-application-properties" class="headerlink" title="配置 application.properties"></a>配置 application.properties</h2><p>SpringBoot 默认的数据库是 H2， 我们可以在<code>application.properties</code> 文件中设定我们所需要的配置。<code>application.properties</code> 文件的目录为<code>src/main/resources/applications.properties</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">spring.jpa.hibernate.ddl-auto=update</div><div class="line">spring.datasource.url=jdbc:mysql://$&#123;MYSQL_HOST:localhost&#125;:3306/db_example</div><div class="line">spring.datasource.username=springuser</div><div class="line">spring.datasource.password=ThePassword</div></pre></td></tr></table></figure><p>这里<code>spring.jpa.hibernate.ddl-auto</code>可以是 <code>none</code>, <code>update</code>,<code>create</code>,<code>create-drop</code>。</p><ul><li>none: 默认值，不会改变数据库结构</li><li>update：会根据 <code>Entity</code>(后面会讲)改变数据库结构</li><li>create: 每次都会创建新的数据库，关闭时不会删除</li><li>create-drop：类似上一个</li></ul><p><code>update</code> 是指在我们设置好<code>Entity</code>后， 如果数据库中没有一个表符合这个 Entity，它会自动创建一个表。所以如果我们数据库中原有我们要操作的表，我们就不需要设置为 update。</p><h2 id="创建-Entity"><a href="#创建-Entity" class="headerlink" title="创建 Entity"></a>创建 Entity</h2><p>创建一个类，设置好各属性，及其 setter</p><p>如果需要通过哪项进行查找，如要执行等同 <code>select * where name=xxx</code> 的操作，则要设置该属性的 getter 方法。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> hello;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.persistence.Entity;</div><div class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</div><div class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</div><div class="line"><span class="keyword">import</span> javax.persistence.Id;</div><div class="line"></div><div class="line"><span class="meta">@Entity</span> <span class="comment">// This tells Hibernate to make a table out of this class</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span></div><div class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.AUTO, generator = <span class="string">"native"</span>)</div><div class="line">    <span class="meta">@GenericGenerator</span>(name = <span class="string">"native"</span>, strategy = <span class="string">"native"</span>)</div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"id"</span>, updatable = <span class="keyword">false</span>, nullable = <span class="keyword">false</span>)</div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String email;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> id;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.id = id;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> email;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.email = email;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种 entity 会被 Hibernate 自动转换进 table</p><h2 id="创建-repository"><a href="#创建-repository" class="headerlink" title="创建 repository"></a>创建 repository</h2><p>创建一个 repository 接口用于之后操作</p><p>其默认的方法有限，如果我们希望通过其他属性查找，如通过 <code>name</code>，需要加一个 <code>findByName(String name)</code>方法声明。如果通过两个属性一起查找，则添加 <code>findByNameAndEmail(String name, String email)</code> 在 Entity 中要有气 getter 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> hello;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.data.repository.CrudRepository;</div><div class="line"><span class="keyword">import</span> hello.User;</div><div class="line"></div><div class="line"><span class="comment">// This will be AUTO IMPLEMENTED by Spring into a Bean called userRepository</span></div><div class="line"><span class="comment">// CRUD refers Create, Read, Update, Delete</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">    <span class="function">List&lt;User&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>;</div><div class="line">    <span class="function">List&lt;User&gt; <span class="title">findByNameAndEmail</span><span class="params">(String name, String email)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="执行操作"><a href="#执行操作" class="headerlink" title="执行操作"></a>执行操作</h2><p>通过例子来看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> hello;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</div><div class="line"></div><div class="line"><span class="meta">@Controller</span>    <span class="comment">// This means that this class is a Controller</span></div><div class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/demo"</span>) <span class="comment">// This means URL's start with /demo (after Application path)</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainController</span> </span>&#123;</div><div class="line"><span class="meta">@Autowired</span> <span class="comment">// This means to get the bean called userRepository</span></div><div class="line">           <span class="comment">// Which is auto-generated by Spring, we will use it to handle the data</span></div><div class="line"><span class="keyword">private</span> UserRepository userRepository;</div><div class="line"></div><div class="line"><span class="meta">@PostMapping</span>(path=<span class="string">"/add"</span>) <span class="comment">// Map ONLY POST Requests</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">addNewUser</span> <span class="params">(@RequestParam String name</span></span></div><div class="line">, @RequestParam String email) &#123;</div><div class="line"><span class="comment">// @ResponseBody means the returned String is the response, not a view name</span></div><div class="line"><span class="comment">// @RequestParam means it is a parameter from the GET or POST request</span></div><div class="line"></div><div class="line">User n = <span class="keyword">new</span> User();</div><div class="line">n.setName(name);</div><div class="line">n.setEmail(email);</div><div class="line">userRepository.save(n);</div><div class="line"><span class="keyword">return</span> <span class="string">"Saved"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@GetMapping</span>(path=<span class="string">"/all"</span>)</div><div class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">Iterable&lt;User&gt; <span class="title">getAllUsers</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">// This returns a JSON or XML with the users</span></div><div class="line"><span class="keyword">return</span> userRepository.findAll();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="CrudRepository-接口常用方法"><a href="#CrudRepository-接口常用方法" class="headerlink" title="CrudRepository 接口常用方法"></a>CrudRepository 接口常用方法</h2><p>继承时，<code>CrudRepository&lt;T, ID&gt;</code> ID 添 ID 的类型</p><ul><li>count(): 返回所有 entities 的数量（return long ）</li><li>save(): 保存该 entity，如果该 entity 是 new 出来的，则是添加新的，如果该 entity 是通过 find 方法得到的引用，则更新该 entity。</li><li>delete(T entity)</li><li>findByID(ID id)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实习过程中需要自己起一个 Springboot 项目并要与 MySQL 交互，第二次更新项目内容时所作记录以防遗忘。&lt;/p&gt;
&lt;p&gt;基本的 SpringBoot 知识与 MySQL 都不会介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Spring" scheme="http://zhstark.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>double类型比较</title>
    <link href="http://zhstark.com/2019/07/30/double%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/"/>
    <id>http://zhstark.com/2019/07/30/double类型比较/</id>
    <published>2019-07-31T01:29:51.000Z</published>
    <updated>2019-08-14T10:03:46.842Z</updated>
    
    <content type="html"><![CDATA[<p>两个 double 类型判断是否相等不能用 <code>d1==d2</code>，这是因为在计算机内部表示小数时（包括 float 和 double 型小数）都有误差。判断两个小数是否相等，只能判断他们之差的绝对值是不是在一个很小的范围里。因此判断需要用一个函数<code>equal(a,b)</code>，这个函数自己写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((a- b&gt; -<span class="number">0.000001</span>) &amp;&amp; (a- b) &lt; <span class="number">0.000001</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;两个 double 类型判断是否相等不能用 &lt;code&gt;d1==d2&lt;/code&gt;，这是因为在计算机内部表示小数时（包括 float 和 double 型小数）都有误差。判断两个小数是否相等，只能判断他们之差的绝对值是不是在一个很小的范围里。因此判断需要用一个函数&lt;code
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>补码</title>
    <link href="http://zhstark.com/2019/06/03/%E8%A1%A5%E7%A0%81/"/>
    <id>http://zhstark.com/2019/06/03/补码/</id>
    <published>2019-06-04T04:19:01.000Z</published>
    <updated>2019-06-03T13:19:46.493Z</updated>
    
    <content type="html"><![CDATA[<p>反码不必多说，直接取反。</p><p>那如何求一个二进制数的补码呢？</p><p>先对它进行一次反码，然后再加 1 得到结果。</p><p>计算机中存储整数，如果是非负数，直接存其二进制，如果是复数，取其补码储存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反码不必多说，直接取反。&lt;/p&gt;
&lt;p&gt;那如何求一个二进制数的补码呢？&lt;/p&gt;
&lt;p&gt;先对它进行一次反码，然后再加 1 得到结果。&lt;/p&gt;
&lt;p&gt;计算机中存储整数，如果是非负数，直接存其二进制，如果是复数，取其补码储存。&lt;/p&gt;

      
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://zhstark.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CAP定理</title>
    <link href="http://zhstark.com/2019/05/28/CAP%E5%AE%9A%E7%90%86/"/>
    <id>http://zhstark.com/2019/05/28/CAP定理/</id>
    <published>2019-05-29T06:11:43.000Z</published>
    <updated>2019-05-28T15:12:16.486Z</updated>
    
    <content type="html"><![CDATA[<p>直接看<a href="http://www.ruanyifeng.com/blog/2018/07/cap.html" target="_blank" rel="external">大佬的博客</a>吧。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;直接看&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/07/cap.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;大佬的博客&lt;/a&gt;吧。。。&lt;/p&gt;

      
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://zhstark.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>线程间通信</title>
    <link href="http://zhstark.com/2019/05/28/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://zhstark.com/2019/05/28/线程间通信/</id>
    <published>2019-05-28T23:58:37.000Z</published>
    <updated>2019-05-28T12:55:36.785Z</updated>
    
    <content type="html"><![CDATA[<p>锁机制：包括互斥锁、条件变量、读写锁</p><ul><li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。</li><li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</li><li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul><p>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</p><p>信号机制(Signal)：类似进程间的信号处理</p><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;锁机制：包括互斥锁、条件变量、读写锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥锁提供了以排他方式防止数据结构被并发修改的方法。&lt;/li&gt;
&lt;li&gt;读写锁允许多个线程同时读共享数据，而对写操作是互斥的。&lt;/li&gt;
&lt;li&gt;条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://zhstark.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>进程间的通信</title>
    <link href="http://zhstark.com/2019/05/28/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>http://zhstark.com/2019/05/28/进程间的通信/</id>
    <published>2019-05-28T23:41:56.000Z</published>
    <updated>2019-05-28T08:51:53.468Z</updated>
    
    <content type="html"><![CDATA[<p>管道，FIFO，消息队列，信号，信号量，Socket，共享内存。</p><p>转载自<a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="external">简书</a>.</p><a id="more"></a><h2 id="进程间通信的概念"><a href="#进程间通信的概念" class="headerlink" title="进程间通信的概念"></a>进程间通信的概念</h2><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）</p><p><img src="/images/DraggedImage.c63c225d88444d1d923ff7add8c104c5.tiff" alt=""></p><h2 id="进程间通信的7种方式"><a href="#进程间通信的7种方式" class="headerlink" title="进程间通信的7种方式"></a>进程间通信的7种方式</h2><h3 id="管道-匿名管道-pipe"><a href="#管道-匿名管道-pipe" class="headerlink" title="管道/匿名管道(pipe)"></a>管道/匿名管道(pipe)</h3><ul><li>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</li><li>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</li><li>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</li><li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</li></ul><p><img src="/images/DraggedImage.6418f939495e489298d40332e49ad5ef.tiff" alt=""></p><p><strong>管道的实质：</strong></p><p>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。</p><p>该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。</p><p>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p><p><strong>管道的局限：</strong></p><p>管道的主要局限性正体现在它的特点上：</p><ul><li>只支持单向数据流；</li><li>只能用于具有亲缘关系的进程之间；</li><li>没有名字；</li><li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；</li><li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</li></ul><h3 id="有名管道-FIFO"><a href="#有名管道-FIFO" class="headerlink" title="有名管道(FIFO)"></a>有名管道(FIFO)</h3><p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)。</p><p>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循先进先出(first in first out),对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。有名管道的名字存在于文件系统中，内容存放在内存中。</p><blockquote><p><strong>匿名管道和有名管道总结：</strong><br>（1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。<br>（2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。<br>（3）无名管道阻塞问题：无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。<br>（4）有名管道阻塞问题：有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</p></blockquote><h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a>信号(Signal)</h3><ul><li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li><li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</li><li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li></ul><blockquote><p><strong>Linux系统中常用信号：</strong><br>（1）SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。<br>（2）SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。<br>（3）SIGQUIT：程序退出信号。程序运行过程中，按Ctrl+\键将产生该信号。<br>（4）SIGBUS和SIGSEGV：进程访问非法地址。<br>（5）SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。<br>（6）SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。<br>（7）SIGTERM：结束进程信号。shell下执行kill 进程pid发送该信号。<br>（8）SIGALRM：定时器信号。<br>（9）SIGCLD：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</p></blockquote><p><strong>信号来源</strong></p><p>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：</p><ul><li>硬件来源：用户按键输入Ctrl+C退出、硬件异常如无效的存储访问等。</li><li>软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。</li></ul><p><strong>信号生命周期和处理流程</strong></p><ol><li>信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；</li><li>操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。</li><li>目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</li></ol><h3 id="消息-Message-队列"><a href="#消息-Message-队列" class="headerlink" title="消息(Message)队列"></a>消息(Message)队列</h3><ul><li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</li><li>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</li><li>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。延伸阅读：消息队列C语言的实践</li></ul><blockquote><p><strong>消息队列特点总结：</strong><br>（1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.<br>（2）消息队列允许一个或多个进程向它写入与读取消息.<br>（3）管道和消息队列的通信数据都是先进先出的原则。<br>（4）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。<br>（5）消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。<br>（6）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</p></blockquote><h3 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h3><ul><li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li><li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</li><li>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</li></ul><h3 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h3><p>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。</p><p>为了获得共享资源，进程需要执行下列操作：</p><ol><li>创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。</li><li>等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。</li><li>挂出一个信号量：该操作将信号量的值加1，也称为V操作。</li></ol><p>为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。Linux环境中，有三种类型：Posix（可移植性操作系统接口）有名信号量（使用Posix IPC名字标识）、Posix基于内存的信号量（存放在共享内存区中）、System V信号量（在内核中维护）。这三种信号量都可用于进程间或线程间的同步。</p><blockquote><p><strong>信号量与普通整型变量的区别：</strong><br>（1）信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；<br>（2）操作也被成为PV原语（P来源于荷兰语proberen”测试”，V来源于荷兰语verhogen”增加”，P表示通过的意思，V表示释放的意思），而普通整型变量则可以在任何语句块中被访问；</p><p><strong>信号量与互斥量之间的区别：</strong><br>（1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。<br>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。<br>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。<br>在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源<br>（2）互斥量值只能为0/1，信号量值可以为非负整数。<br>也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。<br>（3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</p></blockquote><h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h3><p>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p><p>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p><p><strong>套接字特性</strong><br>套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。<br>（1）套接字的域<br>它指定套接字通信中使用的网络介质，最常见的套接字域有两种：<br>一是AF_INET，它指的是Internet网络。当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用socket作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。<br>另一个域AF_UNIX，表示UNIX文件系统，它就是文件输入/输出，而它的地址就是文件名。<br>（2）套接字的端口号<br>每一个基于TCP/IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留Socket中的输入/输出信息，端口号是一个16位无符号整数，范围是0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。<br>（3）套接字协议类型<br>因特网提供三种通信机制，<br>一是流套接字，流套接字在域中通过TCP/IP连接实现，同时也是AF_UNIX中常用的套接字类型。流套接字提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。<br>二个是数据报套接字，它不需要建立连接和维持一个连接，它们在域中通常是通过UDP/IP协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。<br>三是原始套接字，原始套接字允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW。</p><p>原始套接字与标准套接字的区别在于：<br>原始套接字可以读写内核没有处理的IP数据包，而流套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。</p><p>套接字通信的建立</p><p><img src="/images/DraggedImage.287e48b5da3e4f17a3b87e308c37d3cd.tiff" alt="Socket通信基本流程"></p><p><strong> 服务器端</strong></p><ol><li>首先服务器应用程序用系统调用socket来创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，它不能与其他的进程共享。</li><li>然后，服务器进程会给套接字起个名字，我们使用系统调用bind来给套接字命名。然后服务器进程就开始等待客户连接到这个套接字。</li><li>接下来，系统调用listen来创建一个队列并将其用于存放来自客户的进入连接。</li><li>最后，服务器通过系统调用accept来接受客户的连接。它会创建一个与原有的命名套接不同的新套接字，这个套接字只用于与这个特定客户端进行通信，而命名套接字（即原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。</li></ol><p><strong>客户端</strong></p><ol><li>客户应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。</li><li>一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;管道，FIFO，消息队列，信号，信号量，Socket，共享内存。&lt;/p&gt;
&lt;p&gt;转载自&lt;a href=&quot;https://www.jianshu.com/p/c1015f5ffa74&quot;&gt;简书&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://zhstark.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>进程与线程的区别</title>
    <link href="http://zhstark.com/2019/05/28/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://zhstark.com/2019/05/28/进程与线程的区别/</id>
    <published>2019-05-28T23:40:34.000Z</published>
    <updated>2019-05-28T08:41:02.459Z</updated>
    
    <content type="html"><![CDATA[<p>一个任务就是一个进程（Process），在一个进程内部，要同时干多件事情，就需要同时运行多个“子任务”，这些“子任务”称为线程（Thread）。</p><a id="more"></a><p>进程和线程的主要区别在于他们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。所以多进程的程序要比多线程的程序健壮，但在进程切换时，消耗资源较大，效率要差一些。</p><ul><li>进程是资源分配的最小单位，线程是程序执行的最小单位。</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。</li><li>线程是共享进程中的数据的，使用相同的地址空间，因此 CPU 切换一个线程的花费远比进程要小的多，同时创建一个线程的开销也比进程要小很多。</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量，静态变量等数据，而进程之间的通信需要以 IPC（InterProcess Communication) 的方式进行。不过如何处理好同步与互斥是编写多线程程序的难点。</li><li>多进程程序更健壮。因为进程有自己独立的空间。</li></ul><p>一个进程至少有一个线程，多线程的执行方式和多进程是一样的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个任务就是一个进程（Process），在一个进程内部，要同时干多件事情，就需要同时运行多个“子任务”，这些“子任务”称为线程（Thread）。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://zhstark.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>进程与线程的简单解释</title>
    <link href="http://zhstark.com/2019/05/28/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A/"/>
    <id>http://zhstark.com/2019/05/28/进程与线程的简单解释/</id>
    <published>2019-05-28T18:06:50.000Z</published>
    <updated>2019-05-28T03:16:38.274Z</updated>
    
    <content type="html"><![CDATA[<p>转载自<em><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="external">阮一峰的网络日志</a></em></p><a id="more"></a><p>进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。</p><p>最近，我读到一篇材料，发现有一个很好的类比，可以把它们解释地清晰易懂。</p><p>1.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042401.jpg" alt=""></p><p>计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。</p><p>2.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042402.png" alt=""></p><p>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。</p><p>3.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042403.jpg" alt=""></p><p>进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。</p><p>4.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042404.jpg" alt=""></p><p>一个车间里，可以有很多工人。他们协同完成一个任务。</p><p>5.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042405.jpg" alt=""></p><p>线程就好比车间里的工人。一个进程可以包括多个线程。</p><p>6.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042406.png" alt=""></p><p>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</p><p>7.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042407.jpg" alt=""></p><p>可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</p><p>8.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042408.jpg" alt=""></p><p>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</p><p>9.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042409.jpg" alt=""></p><p>还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</p><p>10.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042410.jpg" alt=""></p><p>这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。</p><p>不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</p><p>11.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042411.png" alt=""></p><p>操作系统的设计，因此可以归结为三点：</p><p>（1）以多进程形式，允许多个任务同时运行；</p><p>（2）以多线程形式，允许单个任务分成不同的部分运行；</p><p>（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自&lt;em&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html&quot;&gt;阮一峰的网络日志&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://zhstark.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>关于网络的一些基础知识</title>
    <link href="http://zhstark.com/2019/05/28/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://zhstark.com/2019/05/28/关于网络的一些基础知识/</id>
    <published>2019-05-28T17:48:20.000Z</published>
    <updated>2019-05-28T03:50:11.875Z</updated>
    
    <content type="html"><![CDATA[<p>包括网络模型，TCP 的三次握手四次挥手，流量控制、拥塞控制以及 HTTP 的一些基础知识点。</p><a id="more"></a><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p><img src="/images/网络.png" alt=""></p><ul><li>OSI 七层模型。自下向上：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</li><li>TCPIP 四层模型：网络接口层，网际层，传输层，应用层</li></ul><h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP UDP"></a>TCP UDP</h2><p>所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="/images/DraggedImage.jpg" alt=""></p><p>A 先说“我不玩了”，进入 FIN_WAIT_1状态，<br>B 接收，发送“知道了”，进入 CLOSE_WAIT 状态<br>A 接收，进入 FIN_WAIT_2状态（等待超时 if B 跑路）<br>B 发送“我不玩了”<br>A 接收，发送回应（ACK），结束 FIN_WAIT_2状态，进入 TIME_WAIT.</p><p>TIME_WAIT 为两个 MSL（最大报文存活时长）</p><p><strong>为什么两个最大报文存活时长</strong></p><ol><li>确保最后一个确认报文段能够到达。如果 B 没有收到 A 发来的确认报文段，那么久会重新发送连接释放请求报文段，A 等待一段时间就是为了处理这种情况的发生。</li><li>可能存在“已失效的连接请求报文段”，为了防止这种报文段出现在本次链接之外，需要等待一段时间，防止串话。</li></ol><p><img src="/images/DraggedImage.eff5d057f282408e8046d1cfc197adde.png" alt=""></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://static001.geekbang.org/resource/image/66/a2/666d7d20aa907d8317af3770411f5aa2.jpg" alt=""></p><p>一开始，客户端和服务端都处于 close 状态，先是服务端主动监听某个端口，处于 <em>Listen</em> 状态，然后客户端主动发起建立<em>SYN</em>，处于<em>SYN-SEND 状态</em>，服务端收到发起的连接，返回<em>SYN</em>，并且 ACK 客户端的 SYN，处于<em>SYN-RCVD</em>状态，客户端收到服务端的 SYN 和 ACK之后，发送 ACK 的 ACK，然后处于<em>ESTABLISHED</em>状态。服务端收到 ACK 的 ACK 之后，处于<em>ESTABLISHED</em>状态。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>为了保障顺序性，每一个包都有一个 ID。为了保证不丢包，对于发送的包都要进行应答。但是这个应答也不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这样的模式称为<strong>累计确认</strong>或者<strong>累计应答</strong>（cumulative acknowledgment）。</p><p>TCP 将所有的包按照 ID 的排列划分：</p><ol><li>第一部分，发送了并且已经确认的</li><li>第二部分，发送了并且尚未确认的</li><li>第三部分，没有发送，但是已经等待发送的</li><li>第四部分，没有发送，而且暂时也不会发送</li></ol><p>在 TCP 里，接收端会给发送端报一个窗口的大小，叫做<em>Advertised window</em>。这个窗口的大小应该等于上面两个的第二部分加上第三部分。在对包的确认中，同时会携带一个窗口的大小。<strong>滑动窗口（rwnd）</strong>是怕发送方把接收方缓存塞满。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>滑动窗口是怕发送方把接收方缓存塞满，而<strong>拥塞窗口（cwnd）</strong>是怕把网络塞满。</p><p>TCP 的拥塞控制主要来避免两种现象：<strong>包丢失</strong>和<strong>超时重传</strong></p><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>一条 TCP 连接开始，cwnd 设置为一个报文段，一次只能发送一个；当收到这一个确认的时候，cwnd+1，于是一次能够发送两个；当这两个的确认到来的时候，每个确认 cwnd+1，两个确认 cwnd+2，于是一次能够发送四个；当这四个确认到来的时候，每个确认 cwnd+1，四个确认 cwnd+4，于是一次能够发送八个，所以是指数型增长。</p><p>涨到什么时候是个头呢，有一个值 ssthresh（slow start threshold） 为 65535 个字节，当超过这个值的时候，就不那么快了。</p><p>这时，每收到一个确认后，cwnd 增加 1/cwnd，我们接着上面的过程，一次发送八个，当八个确认到来的时候，每个确认增加 1/8，八个确认一共 cwnd+1，于是一次能够发送九个，变成了线性增长。</p><p>但只要增长就会越来越多。直到有一天，水满则溢，出现了拥塞，这时候一般就会一下子降低倒水的速度。</p><p>拥塞的一种表现形式是丢包，需要超时重传。这个时候，将 ssthresh 设为 cwnd/2，将 cwnd 设为 1，重新开始慢启动。但这种方式太激进了，将一个高速的传输速度一下子停了下来，会造成网络卡顿。</p><h4 id="快速重传算法"><a href="#快速重传算法" class="headerlink" title="快速重传算法"></a>快速重传算法</h4><p>当接收端发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速的重传，不必等待超时再重传。这时 cwnd=cwnd/2，ssthresh=cwnd，当三个包返回的时候，cwnd=ssthresh+3。</p><p>后来还有<strong>BBR 拥塞算法</strong>，它企图找到一个平衡点，就是通过不断的加快发送速度，将管道填满，但是不填满中间设备的缓存，因为这样延时会增加。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="What-will-happen-when-you-input-URL-into-Browser"><a href="#What-will-happen-when-you-input-URL-into-Browser" class="headerlink" title="What will happen when you input URL into Browser."></a>What will happen when you input URL into Browser.</h3><ol><li>Use the URL to get the IP address by submit it to ISP and DMS turn it into IP address</li><li>New HTTP request is sent including your IP address. the time you sent it and the page you asking for</li><li>The server get the request. go the database to get the data, compile them into a long html file and send it back to your IP as HTTP response</li><li>The browser render the page.</li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>GET。GET 就是去服务器获取一些资源。</li><li>POST。它需要主动告诉服务端一些信息。要告诉服务端什么呢？一般会放到正文里。（常见格式 JSON）</li><li>PUT。向指定资源位置上传最新内容。</li><li>DELETE。用来删除资源</li></ul><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><ul><li>IP 地址是一个网卡在网络世界中的通讯地址，相当于现实世界中的门牌号</li><li>无类型域间选路 CIDR （Classless Inter-Domain Routing）xx.xxx.xxx.xx/24 32位中，前24位是网络号</li><li>将子网掩码和 IP 地址按位运算AND，就得到网络号</li><li>IP 是地址，有定位功能， MAC 是身份证，无定位功能</li><li>CIDR 可以判断是不是本地</li></ul><p>DHCP 动态主机配置协议</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;包括网络模型，TCP 的三次握手四次挥手，流量控制、拥塞控制以及 HTTP 的一些基础知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="网络" scheme="http://zhstark.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>关于数据库的一些基础知识</title>
    <link href="http://zhstark.com/2019/05/27/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://zhstark.com/2019/05/27/关于数据库的一些基础知识/</id>
    <published>2019-05-28T04:07:29.000Z</published>
    <updated>2019-05-27T13:11:43.570Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些关于数据库的常考知识点，包括三大范式，锁，MySQL 的 B+树索引</p><a id="more"></a><h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><p>减少冗余，将具有紧密逻辑联系的属性放到同一个关系中。</p><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>描述一个关系中属性之间的联系。设 A 和 B 均为关系 R 的属性，若 A 的每个值都和 B 中的一个唯一的值相对应，则称 B 函数依赖与 A，记为 A→B</p><h3 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h3><p>假设 A 和 B 是某一关系的属性，若 B 函数依赖于 A，但不函数依赖于 A 的任意一个真子集，则称 B 完全函数依赖与 A。</p><p>对于函数依赖A→B，如果去掉 A 的任意一个属性使得该依赖不成立，那么 B 完全函数依赖于 A。</p><h3 id="非范式"><a href="#非范式" class="headerlink" title="非范式"></a>非范式</h3><p>包含一个或多个重复的表</p><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>数据库表中的所有字段值都是不可分解的原子值</p><h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>满足第一范式的要求并且每个非主关键字属性都完全函数依赖于主关键字的关系。<br>将第一范式规范化为第二范式是为了消除部分依赖。</p><h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>满足第一第二范式并且所有非主关键属性都不传递依赖于主关键字的关系。<br>将2NF 规范化为3NF 需要消除传递依赖。如果存在传递依赖，就将传递依赖的属性移到一个新的关系中，并将这些属性的决定方也复制到该关系中。</p><h2 id="ACID-事务的4个基本性质"><a href="#ACID-事务的4个基本性质" class="headerlink" title="ACID 事务的4个基本性质"></a>ACID 事务的4个基本性质</h2><ul><li>A, atomicity 原子性：要么全部执行，要么全部不执行</li><li>C, Consistency 一致性：事务必须将数据库从一种一致的状态转换到另一种一致的状态。</li><li>I, Isolation 隔离性：事务的执行是相互独立的，未完成的事务的中间结果对其他事务是不可见的。</li><li>D, Durability 持久性：成功提交的事务的结果要永久的记录在数据库中，不能因为以后的故障而丢失。</li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁/悲观锁"></a>乐观锁/悲观锁</h3><p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。</p><p>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。</p><p>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</p><p>从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁（Deadlock）就是指两个或两个以上的进程在执行的过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><h4 id="四个充要条件"><a href="#四个充要条件" class="headerlink" title="四个充要条件"></a>四个充要条件</h4><ol><li><p>互斥条件： 指进程对所分配的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直到占有资源的进程用完后释放资源。</p></li><li><p>占有且等待条件： 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但它不会释放自己已经占有的资源。</p></li><li><p>非抢占条件： 指进程已经获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p></li><li><p>循环等待条件 存在一个封闭的进程链，使得每个资源至少占有此链中下一个进程所需要的一个资源。</p></li></ol><h2 id="MySQL-数据库索引：B-树"><a href="#MySQL-数据库索引：B-树" class="headerlink" title="MySQL 数据库索引：B+树"></a>MySQL 数据库索引：B+树</h2><p>我们希望通过索引，查询数据的效率尽可能的高；在存储空间方面，我们希望索引不要消耗太多的内存空间。</p><p>大部分数据结构都不支持按区间查找。</p><p>B+树由二叉搜索树演化而来。为了让二叉搜索树支持按照区间来查找数据，我们将树中的节点并不存储数据本身，而是只作为索引。除此之外，我们把每个叶子节点穿在一条链表上，链表中的数据是从小到大有序的。改造之后，如果我们要求某个区间的数据，我们只需要那区间的初始值，在树中进行查找，当找到某个叶子节点之后，再顺着链表往后遍历，直到链表中的节点数据值大于区间的终止值为止。</p><p>由于数据库中数据量太大，不可能存入内存中，所以我们只能将索引存储在硬盘中，每个节点的读取（或访问）都对应一次磁盘的 IO 操作。那么树的高度就等于每次查询数据时磁盘 IO 操作的次数。</p><p>而硬盘的读取速度太慢，所以需要尽可能减少磁盘 IO 操作，也就是降低树的高度。</p><p>那么我们将索引构建成 m 叉树就可以减小树的高度。但 m 并不是越大越好。</p><p>不管是内存中的数据，还是磁盘中的数据，操作系统都是按页来读取的，一次会读取一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只一次磁盘 IO 操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些关于数据库的常考知识点，包括三大范式，锁，MySQL 的 B+树索引&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://zhstark.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>重学c++5 函数</title>
    <link href="http://zhstark.com/2019/04/25/%E9%87%8D%E5%AD%A6cpp%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/"/>
    <id>http://zhstark.com/2019/04/25/重学cpp函数的参数/</id>
    <published>2019-04-26T06:15:18.000Z</published>
    <updated>2019-05-01T13:31:48.301Z</updated>
    
    <content type="html"><![CDATA[<p>关于：形参于实参, 声明, 分离式编译, 数组参数, main 函数参数, 可变参数，默认实参，函数指针</p><a id="more"></a><h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><p>函数定义时参数列表里的是形参（parameter），使用函数时，放进圆括号里的是实参（argument）。实参是形参的初始值。</p><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><p>因为函数的声明不包含函数体，所以也就无须形参的名字。所以在函数的生命中经常省略形参的名字。</p><p>函数声明也称为函数原型</p><h3 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h3><p>分离式编译允许我们吧程序分割到几个文件中去，每个文件独立编译。</p><p>如果我们修改了其中一个源文件，那么只需要重新编译那个改动了的文件。这一过程通常会产生的一个后缀名是<code>.obj</code> 或者 <code>.o</code>的文件。后缀名的含义是该文件包含对象代码 (object code)。接下来编译器负责吧对象文件链接到一起形成可执行文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ CC -c main.cc <span class="meta"># generates main.o</span></div><div class="line">$ CC -c fact.cc <span class="meta"># generates fact.o</span></div><div class="line">$ CC main.o fact.o -o main <span class="meta"># generate main or main.exe</span></div></pre></td></tr></table></figure><h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</div></pre></td></tr></table></figure><h4 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void print(int (&amp;arr)[10])&#123;</div><div class="line">.....</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>只能将函数作用于大小为 10 的数组。</p><h4 id="传递多维数组"><a href="#传递多维数组" class="headerlink" title="传递多维数组"></a>传递多维数组</h4><p>首元素本身就是一个数组， 指针就是一个指向数组的指针。数组的第二维的大小都是数组类型的一部分，不能省略。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void print(int maxtrix[][10], int rowSize)&#123;&#125;</div><div class="line">void print(int (*matrix)[10], int rowSize)&#123;...&#125; //matrix 为指向含有 10 个整数的数组的指针</div><div class="line"></div><div class="line">int *matrix[10]; //10个指针构成的数组</div><div class="line">int (*matrix)[10];//指向含有 10 个整数的数组的指针</div></pre></td></tr></table></figure><h3 id="main-函数的参数"><a href="#main-函数的参数" class="headerlink" title="main 函数的参数"></a>main 函数的参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;...&#125;</div><div class="line"><span class="comment">//argv 是一个数组，他的元素是指向 C 风格字符串的指针；argc 表示数组中字符串的数量。</span></div><div class="line"><span class="comment">//因为第二个形参是数组，所以也可写成：</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;...&#125;</div><div class="line"><span class="comment">//argv 指向 char*</span></div></pre></td></tr></table></figure><p>假设 main 函数位于可执行文件 a 里，我们可以向程序传递下面的选项</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a -d -o ofile data0</div></pre></td></tr></table></figure><p>此时，argc=5，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">argv[<span class="number">0</span>]=<span class="string">"a"</span>;</div><div class="line">argv[<span class="number">1</span>]=<span class="string">"-d"</span>;</div><div class="line">argv[<span class="number">2</span>]=<span class="string">"-o"</span>;</div><div class="line">argv[<span class="number">3</span>]=<span class="string">"ofile"</span>;</div><div class="line">argv[<span class="number">4</span>]=<span class="string">"data0"</span>;</div><div class="line">argv[<span class="number">5</span>]=<span class="string">'\0'</span>;</div></pre></td></tr></table></figure><p>所以用 argv 的实参时要从 <code>argv[1]</code>开始。</p><h3 id="可变形参"><a href="#可变形参" class="headerlink" title="可变形参"></a>可变形参</h3><p>对于实参类型相同的，使用<code>initializer_list</code>标准库类型，需要<code>include &lt;initializer_list&gt;</code>。对于实参类型不同的，使用<strong>可变参数模板</strong>。</p><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a=<span class="number">1</span>, <span class="keyword">int</span> b=<span class="number">2</span>)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure><p>一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p><p>函数调用时实参按其位置解析，要想覆盖后面的默认值必须为前面参数提供实参。</p><p>当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。</p><h5 id="默认实参声明"><a href="#默认实参声明" class="headerlink" title="默认实参声明"></a>默认实参声明</h5><p>在给定作用域中一个形参只能被赋予一次默认实参，即函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。</p><h5 id="默认实参初始值"><a href="#默认实参初始值" class="headerlink" title="默认实参初始值"></a>默认实参初始值</h5><p>局部标量不能作为默认实参</p><h3 id="内联函数-inline"><a href="#内联函数-inline" class="headerlink" title="内联函数 inline"></a>内联函数 inline</h3><p>调用函数会包含一系列开销，将函数指定为内联函数，则将它在每个调用点上“内联地”展开。从而消除了调用函数的开销。</p><p>在函数的返回类型前面加上关键字<em>inline</em>，就可以将它声明为内联函数了。</p><p>一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。内联说明只是向编译器发送一个请求，编译器可以选择忽略这个请求。</p><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>函数指针指向某种特定类型，函数的类型由他的返回类型和形参类型共同决定，与函数名无关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</div></pre></td></tr></table></figure><p>该函数的类型是<code>bool(const string&amp;, const string&amp;)</code>。 要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;);</div></pre></td></tr></table></figure><p><code>pf</code>指向一个函数。如果对<code>*pf</code>两端不加括号，那么<code>pf</code>是一个返回值为 bool 指针的函数。</p><p>当我们吧函数名作为一个值使用时，该函数自动转换为指针。</p><h5 id="函数指针形参"><a href="#函数指针形参" class="headerlink" title="函数指针形参"></a>函数指针形参</h5><p>直接使用函数指针类型显得冗长而烦琐，类型别名和<code>decltype</code>可以简化函数指针的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Func and Func2 have function type</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;</div><div class="line"></div><div class="line"><span class="comment">//FuncP and Funcp2 have pointer to function type</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span><span class="params">(*FuncP)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;</div></pre></td></tr></table></figure><p><strong><code>decltype</code>返回函数类型，此时不会将函数类型自动转换成指针类型。</strong></p><h5 id="返回指向函数的指针"><a href="#返回指向函数的指针" class="headerlink" title="返回指向函数的指针"></a>返回指向函数的指针</h5><p>我们必须吧返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。要想声明一个返回函数指针的函数，最简单的办法就是使用类型别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> F=<span class="keyword">int</span>(<span class="keyword">int</span>*, <span class="keyword">int</span>);<span class="comment">//F 是函数类型</span></div><div class="line"><span class="keyword">using</span> PF=<span class="keyword">int</span>(*)(<span class="keyword">int</span>*, <span class="keyword">int</span>);<span class="comment">// PF 是指针类型</span></div></pre></td></tr></table></figure><p>和函数类型的形参不一会，返回类型不会自动地转换成指针。我们必须显式地将返回类型指定为指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="function">F* <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div></pre></td></tr></table></figure><p><strong>如果我们明确知道返回的函数是哪一个，就能使用 decltype 简化书写函数指针返回类型的过程</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span>::<span class="function">size_type <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</div><div class="line"><span class="keyword">decltype</span>(f)* getFcn(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于：形参于实参, 声明, 分离式编译, 数组参数, main 函数参数, 可变参数，默认实参，函数指针&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://zhstark.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>重学cpp4 数组</title>
    <link href="http://zhstark.com/2019/03/25/%E9%87%8D%E5%AD%A6cpp-array/"/>
    <id>http://zhstark.com/2019/03/25/重学cpp-array/</id>
    <published>2019-03-26T04:00:32.000Z</published>
    <updated>2019-04-26T04:30:57.319Z</updated>
    
    <content type="html"><![CDATA[<p>关于数组的声明，指针与二维数组</p><a id="more"></a><h3 id="复杂的数组声明"><a href="#复杂的数组声明" class="headerlink" title="复杂的数组声明"></a>复杂的数组声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];<span class="comment">//ptrs 是一个含有10个 整型指针 的数组</span></div><div class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>]= arr;<span class="comment">// Wrong，不存在引用的数组</span></div><div class="line"><span class="keyword">int</span> (*P)[<span class="number">10</span>]=&amp;arr;<span class="comment">//P是一个指针，指向一个含有10个整数的数组</span></div><div class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>]=arr;<span class="comment">//arrRef 引用一个含有10个整数的数组</span></div><div class="line"><span class="keyword">int</span> * (&amp;arr)[<span class="number">10</span>]=ptrs;<span class="comment">//arr 是数组的引用，该数组含有10个指针</span></div></pre></td></tr></table></figure><h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> nums[]=&#123;<span class="string">"onr"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;;</div><div class="line"><span class="built_in">string</span> *p=nums;<span class="comment">// string *p=&amp;nums[0];</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">p2</span><span class="params">(nums)</span></span>;<span class="comment">//p2为指向字符串的指针，指向 nums 的第一个元素</span></div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">p2</span><span class="params">(&amp;nums[<span class="number">0</span>])</span></span>;</div><div class="line">*p2=<span class="string">"sfa"</span>;</div></pre></td></tr></table></figure><p>当用<code>decltype</code>时，跟上面又不一样了，不再返回指针，而是返回数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ia[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">decltype</span>(ia) ia2=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;<span class="comment">//decltype 返回的类型是由10个整数构成的数组</span></div></pre></td></tr></table></figure><h3 id="把指针当迭代器"><a href="#把指针当迭代器" class="headerlink" title="把指针当迭代器"></a>把指针当迭代器</h3><p>重点在于找到终止点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *e=&amp;arr[<span class="number">10</span>];<span class="comment">//指向 arr 最后一个元素的下一个位置。</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> *b=arr; b!=e; ++b)&#123;&#125;</div><div class="line"><span class="comment">// or</span></div><div class="line"><span class="keyword">int</span> *e=end(arr);<span class="comment">//#include &lt;iterator&gt;</span></div><div class="line"><span class="keyword">int</span> *b=begin(arr);<span class="comment">//This is better</span></div></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;</div><div class="line">&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</div><div class="line">&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</div><div class="line">&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;<span class="comment">//same</span></div></pre></td></tr></table></figure><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p><strong>数组不能被拷贝</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于数组的声明，指针与二维数组&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://zhstark.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>重学c++3 decltype &amp; string</title>
    <link href="http://zhstark.com/2019/03/24/%E9%87%8D%E5%AD%A6cpp-decltype-and-string/"/>
    <id>http://zhstark.com/2019/03/24/重学cpp-decltype-and-string/</id>
    <published>2019-03-25T03:40:32.000Z</published>
    <updated>2019-04-26T04:30:37.878Z</updated>
    
    <content type="html"><![CDATA[<p>关于<code>decltype</code> 和 string 的一些东西。 decltype返回方程的返回类型。</p><a id="more"></a><h2 id="三-decltype"><a href="#三-decltype" class="headerlink" title="三 decltype"></a>三 decltype</h2><p>decltype的作用是选择并返回操作数的数据类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">decltype</span>(f()) s=x;<span class="comment">//s 的类型为函数 f 的返回值类型</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> c1=<span class="number">0</span>, &amp;c2=c1;</div><div class="line"><span class="keyword">decltype</span>(c1) x=<span class="number">0</span>;<span class="comment">//const int x</span></div><div class="line"><span class="keyword">decltype</span>(c2) y=x;<span class="comment">//const int &amp;y=x;</span></div></pre></td></tr></table></figure><p>如果 decltype 的表达式加上了一对括号，这样的 decltype 会得到一个引用类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line"><span class="keyword">decltype</span>((i)) d=i;<span class="comment">//d是一个 int&amp; 引用变量</span></div></pre></td></tr></table></figure><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><h3 id="using-声明"><a href="#using-声明" class="headerlink" title="using 声明"></a>using 声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name;</div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</div></pre></td></tr></table></figure><p>头文件的代码一般不能使用 using 声明，因为头文件的内容会拷贝到所有引用他的文件中去。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="getline-函数"><a href="#getline-函数" class="headerlink" title="getline 函数"></a>getline 函数</h4><p><strong>在最终得到的字符串中保留输入时的空白符</strong><br><code>getline(ins, s)</code> 第一个参数是输入流，第二个参数是 string。函数从输入流中读入内容，直到遇到换行符为止。</p><p><strong>输入运算符作为判断条件</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;value)</div></pre></td></tr></table></figure></p><p><code>cin&gt;&gt;value</code> 返回 cin，一个<code>istream</code> 对象。当使用<code>istream</code>对象作为判断条件时，效果是检测流的状态。当遇到文件结束符或一个无效的输入时，判断为假。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;<span class="built_in">string</span> line;</div><div class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>, line))</div><div class="line"><span class="built_in">cout</span>&lt;&lt;line&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="string-相加"><a href="#string-相加" class="headerlink" title="string 相加"></a>string 相加</h4><p>当把 string 对象和字符字面值及字符串字面值混在一条语句中使用，必须确保每个加法运算符的两侧的运算对象至少有一个是 string<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s4=s1+<span class="string">","</span>;<span class="comment">//right</span></div><div class="line"><span class="built_in">string</span> s5= <span class="string">"hello"</span>+<span class="string">","</span>; <span class="comment">//wrong</span></div><div class="line"><span class="built_in">string</span> s6=s1+<span class="string">","</span>+<span class="string">"hjello"</span>;<span class="comment">//right</span></div><div class="line"><span class="built_in">string</span> s7=<span class="string">"hello"</span>+<span class="string">","</span>+s1;<span class="comment">//wrong</span></div></pre></td></tr></table></figure></p><h4 id="处理字符"><a href="#处理字符" class="headerlink" title="处理字符"></a>处理字符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></div><div class="line"><span class="built_in">isalnum</span>(c)</div><div class="line"><span class="built_in">isalpha</span>(c)</div><div class="line"><span class="built_in">isdigit</span>(c)</div><div class="line"><span class="built_in">islower</span>(c)</div><div class="line"><span class="built_in">isupper</span>(c)</div><div class="line"><span class="built_in">isspace</span>(c)</div><div class="line"><span class="built_in">tolower</span>(c)</div><div class="line"><span class="built_in">toupper</span>(c)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于&lt;code&gt;decltype&lt;/code&gt; 和 string 的一些东西。 decltype返回方程的返回类型。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://zhstark.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>重学C++2  const</title>
    <link href="http://zhstark.com/2019/03/16/%E9%87%8D%E5%AD%A6cpp-const/"/>
    <id>http://zhstark.com/2019/03/16/重学cpp-const/</id>
    <published>2019-03-17T04:27:59.000Z</published>
    <updated>2019-04-26T04:27:00.944Z</updated>
    
    <content type="html"><![CDATA[<p>指向常量的指针，常量指针，指向常量的常量指针 = =！</p><a id="more"></a><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>默认状态下，<code>const</code>对象只在文件内有效。如果只在一个文件中定义 <code>const</code>，而在其他多个文件中声明并使用它，那么对 <code>const</code> 变量不管是声明还是定义都添加<code>extern</code> 关键字。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//file.cc中定义并初始化</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">1</span>;</div><div class="line"><span class="comment">//file.h 中声明</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> a;<span class="comment">//这俩 a 是同一个</span></div></pre></td></tr></table></figure></p><p><strong>对常量的引用（reference to const）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> c1=<span class="number">1</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1=c1;</div><div class="line"><span class="keyword">int</span> &amp;r2=c1;<span class="comment">//错误，非常量引用不能指向常量</span></div></pre></td></tr></table></figure><p><strong>指向常量的指针</strong> 要想放常量的地址，只能用指向常量的指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.14</span>;</div><div class="line"><span class="keyword">double</span> *p1=&amp;pi;<span class="comment">// WRONG!</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> *p2= &amp;pi;<span class="comment">//Right</span></div></pre></td></tr></table></figure></p><h2 id="const-指针"><a href="#const-指针" class="headerlink" title="const 指针"></a>const 指针</h2><p>允许吧指针本身定义为常量，<strong>常量指针</strong>（const pointer）必须初始化。把*放在 const 之前，来说明指针是一个常量，此时不变的是指针本身，而不是指针指向的值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p=&amp;num;<span class="comment">// const pointer，p 不能改，（*p)可以改</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.14</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> p2=&amp;pi;</div></pre></td></tr></table></figure></p><blockquote><p>弄清声明含义可以从右向左读。</p></blockquote><h3 id="顶层-const-amp-底层-const"><a href="#顶层-const-amp-底层-const" class="headerlink" title="顶层 const &amp; 底层 const"></a>顶层 const &amp; 底层 const</h3><p>顶层 const 可以表示任意的对象是常量（如表明指针本身是一个常量），而底层 const 表示指针所指的对象使一个常量。</p><h2 id="常量表达式-const-expression"><a href="#常量表达式-const-expression" class="headerlink" title="常量表达式 const expression"></a>常量表达式 const expression</h2><p>常量表达式是指值不变并且在编译过程就能得到计算结果的表达式。</p><p>C++11允许将变量声明为 <code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量表达式。声明为 constexpr 的变量一定是一个常量，而且必须用常量表达式初始化。（还有 constepr 函数，在编译时计算出结果）。</p><p><strong>在 constexpr 声明中如果定义了一个指针，限定符 constexpr 仅对指针有效，与指针所指的对象无关</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p=<span class="literal">nullptr</span>;<span class="comment">//一个指向整型常量的指针</span></div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q=<span class="literal">nullptr</span>;<span class="comment">//一个指向整数的常量指针</span></div><div class="line"></div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *pp=&amp;i;<span class="comment">//指向常量的常量指针</span></div></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p><strong>类型别名</strong>是一个名字，是某种类型的同义词。有两种方法。</p><p>1.typedef<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages; <span class="comment">//wages 就是 double</span></div><div class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base 就是 double，p 是 double *的同义词</span></div></pre></td></tr></table></figure></p><p>2.别名声明<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> SI=<span class="keyword">int</span>;</div></pre></td></tr></table></figure></p><p><strong>坑</strong>：如果某个类型别名指代的是<strong>复合类型</strong>或<strong>常量</strong>，结果跟你想的可能不太一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;<span class="comment">//pstring 是 char * 别名</span></div><div class="line"><span class="keyword">const</span> pstring cs=<span class="number">0</span>；<span class="comment">// cs 是指向 char 的 “常量指针”！不是指向常量字符的指针</span></div><div class="line"><span class="keyword">const</span> pstring *p;<span class="comment">//p是一个指针，他的对象是指向 char 的常量指针</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;指向常量的指针，常量指针，指向常量的常量指针 = =！&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://zhstark.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>重学 C++</title>
    <link href="http://zhstark.com/2019/03/09/%E9%87%8D%E5%AD%A6%20cpp/"/>
    <id>http://zhstark.com/2019/03/09/重学 cpp/</id>
    <published>2019-03-10T01:38:52.000Z</published>
    <updated>2019-04-26T03:15:57.085Z</updated>
    
    <content type="html"><![CDATA[<p><em>之前学的不够扎实，更加系统、贴近底层的学一遍。非新手笔记，都是比较基础的东西，但没有最最基础的东西</em></p><a id="more"></a><h2 id="零"><a href="#零" class="headerlink" title="零"></a>零</h2><p><code>main</code> 函数的返回类型必须是<code>int</code>，返回 0 表明成功。</p><ul><li>curly brace 花括号</li><li>block of statements 语句块</li><li><p>assignment 赋值</p></li><li><p>windows: <code>.\</code>表示该文件在当前目录中，Unix: <code>./</code> 表示可执行文件在当前目录中。 </p></li><li><p>stream：流，一个流就是一个字符序列。随着时间的推移，字符是顺序生成或消耗的。</p></li><li>cin</li><li>cout</li><li>cerr</li><li>clog</li><li><code>&lt;&lt;</code> 输出运算符，返回其左侧的运算对象</li><li><code>endl</code>是一个被称为操作符(manipulator)的特殊值，写入<code>endl</code>的效果是结束当前行，并将于设备关联的 buffer 中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。</li><li><code>::</code> 作用域运算符</li><li><code>&gt;&gt;</code> 输入运算符，返回左侧运算对象</li></ul><p>当用一个<code>istream</code> 对象作为判断条件时，其效果是检测stream 的状态。当流未遇到错误，即为true。但遇到文件结束符（ctrl+D in Mac）或遇到无效输入，状态变为无效，条件为 false。</p><p><strong>文件重定向</strong> 将标准输入和标准输出与命名文件关联起来。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ addItems &lt;infile&gt;outfile</div></pre></td></tr></table></figure></p><p>addItem 为编译后的可执行文件，上述命令会从一个名为 infile 的文件读取销售记录，并将输出结果写入一个名为 outfile 的文件中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Sale_item.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">Sale_item item1, item2;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;item1&gt;&gt;item2;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;item1+item2&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>可寻址的最小内存块称为 字节 (byte)，存储的基本单元称为 字 (word)，一个字节由八个比特（bit）构成，一个字由32或64比特构成。</p><ul><li><code>char</code> 8位（bits），一字节（bytes）</li><li><code>int</code> 32位，四字节</li><li><code>float</code> ，32位，6位有效数字</li><li><code>double</code> 64位，10位有效数字</li><li><code>char16_t</code> &amp; <code>char32_t</code> 为 Unicode 字符</li><li><code>short</code> 16bits</li><li><code>long</code> 32 bits</li><li><code>long long</code> 64 bits</li><li><code>long double</code> 96 or 128 bits</li><li><code>0</code>开头为八进制，<code>0x</code> 开头十六进制</li></ul><p>执行浮点数运算选用 double， 因为 float 通常精度不够，而且双精度浮点数和单精度浮点数的计算代价差不多。</p><p><strong>勿混用有符号类型与无符号类型</strong><br>如果 int 和无符号运算，那么 int 值会自动转变为无符号数。</p><p>当从无符号数中减去一个值时，不管这个数是不是无符号数，我们都必须确保结果不能是一个负值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> u1=<span class="number">42</span>,u2=<span class="number">10</span>;</div><div class="line"><span class="built_in">cout</span>&lt;&lt;u2-u1&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">输出：<span class="number">4294967264</span></div></pre></td></tr></table></figure><p>浮点数科学计数法表示：指数部分用 E 或 e 标识: <code>24E2</code>-><code>2400</code></p><p><strong>引用（reference）</strong>为对象起了另外一个名字，引用必须被初始化。通过将声明符写成<code>&amp;d</code>的形式来定义引用类型，其中<code>d</code>是声明的变量名。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。即定义了一个引用后，对其进行的所有操作都是在与之绑定的对象上进行的。</p><p><strong>空指针</strong>不指向任何对象，在试图使用一个指针之前代码可以先检测它是否为空。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *p1=<span class="literal">nullptr</span>;<span class="comment">// &lt;--- best</span></div><div class="line"><span class="keyword">int</span> *p2=<span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> *p3=<span class="literal">NULL</span>;<span class="comment">//#include &lt;cstdlib&gt;</span></div></pre></td></tr></table></figure></p><p>把 int 变量直接给指针是错误的，即使该值是0。</p><p><strong>指向指针的引用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</div><div class="line"><span class="keyword">int</span> *p;</div><div class="line"><span class="keyword">int</span> *&amp;r=p;<span class="comment">// r 是一个对指针 p 的引用</span></div><div class="line">r=&amp;i;<span class="comment">// p 指向 r</span></div><div class="line">*r=<span class="number">0</span>;</div></pre></td></tr></table></figure><p>从右向左阅读 r 的定义，首先是<code>&amp;</code>，说明 r 是一个引用，其次是<code>*</code>，表示 r 引用的是指针，最后<code>int</code>，r 引用的是 int 指针。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;之前学的不够扎实，更加系统、贴近底层的学一遍。非新手笔记，都是比较基础的东西，但没有最最基础的东西&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://zhstark.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++函数的参数的不同传递方式</title>
    <link href="http://zhstark.com/2019/02/28/C-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F/"/>
    <id>http://zhstark.com/2019/02/28/C-函数的参数的不同传递方式/</id>
    <published>2019-03-01T06:52:28.000Z</published>
    <updated>2019-03-01T04:49:13.552Z</updated>
    
    <content type="html"><![CDATA[<p>面试要用 C++，没用 C++写过任何 project， 从头开始学 妈耶可烦死我了。</p><p>刷题时看到关于 C++函数的参数传递有好多形式，有直接传的，有传指针的，还有传<code>&amp;</code>，最后一个没怎么见过。找了些资料，发现这些对应的是值传递，指针传递和引用传递。</p><a id="more"></a><p>在这个<a href="https://www.cnblogs.com/yanlingyin/archive/2011/12/07/2278961.html" target="_blank" rel="external">博客</a>找到了非常深入的解释，摘抄部分如下：</p><p>（注：函数中用于接收传递值的变量叫形参，传递给函数的值叫实参）</p><p><strong>值传递</strong>：</p><p>形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-&gt;形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;n++;&#125;    <span class="comment">// 外面传来的 n 不变</span></div></pre></td></tr></table></figure></p><p><strong>指针传递</strong>：</p><p>形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> *n)</span></span>&#123;*n=*n+<span class="number">1</span>;&#125;  <span class="comment">//外面的 n 也变</span></div></pre></td></tr></table></figure></p><p><strong>引用传递</strong>：</p><p>形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> &amp;n)</span></span>&#123;n++;&#125;       <span class="comment">////外面的 n 也变</span></div><div class="line"></div><div class="line"><span class="comment">//对引用传递，传入的时候只是传 n，不同于指针传 &amp;n</span></div><div class="line"><span class="keyword">int</span> n=<span class="number">2</span>;</div><div class="line">f3(n);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试要用 C++，没用 C++写过任何 project， 从头开始学 妈耶可烦死我了。&lt;/p&gt;
&lt;p&gt;刷题时看到关于 C++函数的参数传递有好多形式，有直接传的，有传指针的，还有传&lt;code&gt;&amp;amp;&lt;/code&gt;，最后一个没怎么见过。找了些资料，发现这些对应的是值传递，指针传递和引用传递。&lt;/p&gt;
    
    </summary>
    
      <category term="记录" scheme="http://zhstark.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="tech" scheme="http://zhstark.com/tags/tech/"/>
    
  </entry>
  
</feed>
