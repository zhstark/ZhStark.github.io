<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[存储型XSS攻击与防御]]></title>
    <url>%2F2020%2F11%2F22%2F%E5%AD%98%E5%82%A8%E5%9E%8BXSS%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[工作中网页要添加支持富文本功能，我写的 tech spec 讲富文本直接导出相应的 html format，后端直接存储 html。组里大佬敏锐的提出了直接使用 HTML 的安全隐患。 Storing HTML would make me nervous – there are many potential attack vectors when re-displaying that content on the webpage (especially if you combine that with another ongoing discussion about user impersonation!). We’d probably want to tread lightly here and sanitize the HTML with a whitelist of elements before displaying it back out. 回头自己搜了一下，原来他所担忧的是可能会被 XSS 攻击。 什么是 XSS 攻击XSS 全称Cross Site Script，叫做「跨站脚本攻击」，是指用户注入恶意的代码，如果浏览器和服务器都没有对该输入进行过滤，导致用户注入的脚本嵌入到了页面中。由于浏览器无法识别这些恶意代码正常解析执行，攻击者的恶意操作被成功执行，比如可以获取用户的cookie数据然后发送给自己或者冒充正常用户向被攻击的服务器发送请求。举个简单的例子，用户直接在富文本里写 js 脚本： 1&lt;script&gt;js bad code...&lt;/script&gt; 由于没有过滤，该文本内容会由后端直接返回到其他用户浏览器，那么这段文本可能就不是以文本方式出现，而是被浏览器误以为是要去执行的一段代码，这样就是被攻击了。 防范存储型 XSS 攻击防范 XSS 攻击的奥义在于永远不要相信用户的输入。 先来看看存储型 XSS 的攻击步骤： 1.攻击者将恶意代码提交到目标网站的数据库中。2.用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 XSS 过滤主要有两种模式：黑名单和白名单。 基于黑名单的 XSS 过滤，将转义或移除黑名单中的标签和属性。 基于白名单的 XSS 过滤，仅允许白名单中的标签和属性存在，其他全部转义或移除。 由于使用黑名单可能会有漏网之鱼存在，一般多是采用白名单。 方法也看起来很简单：要求用户仅能输入指定、有限的标签和属性。前端可以通过富文本编辑器配置，仅显示指定标签，提升用用户体验。后端不能直接信任前端数据，需要基于白名单再次过滤。这样可以保证，入库的数据都是可信任的。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自建shadowsocks服务]]></title>
    <url>%2F2020%2F03%2F12%2F%E8%87%AA%E5%BB%BAshadowsocks%E7%BF%BB%E5%A2%99%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[Google Cloud 一年免费，不用白不用，本来是想用来做个微信机器人的，但是在登录的时候发现微信把 web 端关了，没有接口获取数据，直接流产。就先用来搭个FQ服务器吧，以后回国用。 一 安装我这里是 CentOS 系统 可以先进入 root 用户，这样就不用输入 sudo 了 123sudo yum install python-pipsudo yum install python-setuptools &amp;&amp; easy_install pipsudo pip install shadowsocks 二 配置sudo vi /etc/shadowsocks.json 输入下面 12345678910&#123; &quot;server&quot;: &quot;my_server_ip&quot;, // 这里输入本机的 IP 地址 &quot;server_port&quot;: 8388, // 为了安全，可修改为大于 1024 的数字 &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;: 1080, // 为了安全，可修改为大于 1024 的数字 &quot;password&quot;: &quot;mypassword&quot;, // 设置一个密码 &quot;timeout&quot;: 300, &quot;method&quot;: &quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125; 三 qids1$ ssserve -c /etc/shadowsocks.json -d start]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记]]></title>
    <url>%2F2019%2F11%2F19%2FJava%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[刷题过程中常用的一些 Java 的方法、数据结构等 Java 中的数组初始值都为零 long int 强制类型转换12long a=1;int b=(int) a; 集合集合包括两个基本接口：Collection和Map， 所有实现Collection的类都要有下面的方法，这些类可以使用for each的方法来遍历。如果要用迭代器遍历，则是 123456Collections&lt;String&gt; c=...;Iterator&lt;String&gt; it=c.iterator();while(it.hasNext())&#123; String e=it.next(); ...&#125; 123456789101112int size();boolean isEmpty();boolean contains(Object obj);boolean containsAll(Collection&lt;?&gt; c);boolean equals(Object other)boolean addAll(Collection&lt;? extends E&gt; from)boolean remove(Object obj);boolean removeAll(Collection&lt;?&gt; c);void clear();boolean retainAll(Collection&lt;?&gt; c);//从这个集合中删除所有与 other 集合中的元素不同的元素。如果这个调用改变了集合，返回 trueObject[] toArray();&lt;T&gt; T[] toArray(T[] arrayToFill); 键盘读取数据：12Scanner s = new Scanner(System.in); int n = s.nextInt(); // 或者其他数据类型 随机数的写法：1Math.random(); // [0,1) double类型 Integer Max, min12Integer.MAX_VALUE;Integer.MIN_VALUE; Char大小写：12char Character.toLowerCase(char c)char Character.toUpperCase(char c) 判断类型： 1234567boolean Character.isLetterOrDigit(char c)boolean Character.isLetter(char c)boolean Character.isDigit(char c)boolean Character.isLowerCase(char c)boolean Character.isUpperCase(char c)char Character.toLowerCase(char c)char Character.toUpperCase(char c) String：1234567891011121314151617int length()int indexOf(char ch)int indexOf(String str)int lastIndexOf(int ch)int lastIndexOf(String str)String substring(int begin)String substring(int begin, int end)boolean equals(Object obj)char charAt(int index)String[] split(String regex, int limit)例如String[] temp = s.split(&quot;\\s+&quot;);s.trim(); //The java lang.string.trim()is a built-in function that eliminates leading and trailing spaces. 123word.toCharArray()// 变成 char[], 可以用 for each 循环word.toLowerCase();word.toUpperCase(); 比较大小：1234Str1.compareTo(Str2)// &lt;0: s1&lt;s2// =0: s1=s2// &gt;0: s1&gt;s2 String to int/long12345//Integer.parseInt()String number = "10";int result = Integer.parseInt(number); //Long.parseLong(String) Integer to String1s=Integer.toString(1); StringBuilder:1234567StringBuilder append(String str)StringBuilder insert(int pos, String str)StringBuilder delete(int start, int end)StringBuilder replace(int start, int end, String str)SetCharAt(int index, char c);String toString()int length() ArrayList:123456add(Object)add(index, Object)Object remove(pos)Object get(pos)size()set(pos, Object) 排序1Collections.sort(list); 交换1Collections.swap(list, index1, index2) LinkedList:Java 中的 LinkedList 是双向链表123add(Object)Object remove()size() 一件很神奇的事是：Queue\ queue = new LinkedList\&lt;>(); 因为Queue接口是用链表实现的 Queue &amp; Deque123456789101112131415Queue&lt;String&gt; queue=new LinkedList&lt;String&gt;();queue.offer("a"); Or queue.add("a");queue.offer("b");for(String q:queue)&#123;&#125;String p=queue.poll() //返回第一个元素，并在队列中删除Or p=queue.remove();String p2=queue.element();//返回第一个元素String p3=queue.peek();// 返回第一个元素int a=queue.size();q.isEmpty() 123456789101112131415Deque&lt;Integer&gt; dq=new LinkedList();dq.addFirst(1);dq.addLast(2);dq.offerFirst(1);dq.offerLast(2);dq.removeFirst();dq.removeLast();dq.pollFirst();dq.pollLast();dq.getFirst();dq.getLast();dq.peekFirst();dq.peekLast(); HashSet TreeSet12add, remove, removeAll(obj), contains(obj), isEmpty, removeAllfor(char c: set)&#123;&#125; HashMap TreeMap123456789101112131415161718192021Object get(key);Object getOrDefault(key, defaultValue);put(key, value);putAll(Map&lt;&gt; map);remove(key);boolean remove(key, value);boolean containsKey(key);//枚举所有 keySet&lt;String&gt; keys=map.keySet();for(String key: keys)&#123;...&#125;//同时看所有 key 和值Set&lt;Entry&lt;String, String&gt;&gt; entrySet=animal.entrySet(); for(Entry&lt;String, String&gt; entry:entrySet) System.out.println(entry.getKey() + entry.getValue());//大小map.size();for(char c: degree.keySet())&#123; ...&#125; Stack:1234boolean isEmpty()Object peek()Object pop()push(Object) 我就在Hard题里见过的ArrayDeque123456deq.addLast(Object)boolean deq.isEmpty()Object deq.getFirst()deq.removeFirst()Object deq.getLast()deq.removeLast() 1234String s = Arrays.toString(一个数组)List s = Arrays.asList(一个数组)Arrays.sort(一个数组);Math.abs(int); PriorityQueue1234567lambda表达式，以LC973为例//这里注意：要带匿名表达式，`&lt;&gt;`不能省略！！！！PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((p1, p2)-&gt; (p2[0] * p2[0] + p2[1] * p2[1] - p1[0] * p1[0] - p1[1] * p1[1]));add(Object)E peek()E poll()E remove(); 数组 这里是指 形如 int[] 的快速初始化 1Arrays.fill(a, 1); 排序，是更改原数组1Arrays.sort(A); 拷贝（深拷贝）123System.arraycopy(src, srcPos, dest, destPos, length);int[] a2=a1.clone() //深拷贝int[] a3=Arrays.copyOf(a1, 3) // (原数组，拷贝的个数) Pair1234567Pair p1 = new Pair(3,4); Pair p2 = new Pair(3,4); Pair p3 = new Pair(4,4); String toString() // This method will return the String representation of the Pair.K getKey() // It returns key for the pair.V getValue() // It returns value for the pair.int hashCode() // Generate a hash code for the Pair. Comparator 接口比较器是实现了 Comparator 接口的实例123public interface Comparator&lt;T&gt;&#123; int compare(T first, T second);&#125; 比如要比较字符串的长度，可以定义一个实现了这个接口的类12345class LengthComparator implement Comparator&lt;String&gt;&#123; public int compara(String first, String second)&#123; return first.length()-second.length(); &#125;&#125; 具体使用时，需要建立一个实例：12Comparator&lt;String&gt; comp=new LengthComparator();Arrays.sort(list, comp); 也可以声明与实例放一块12345PriorityQueue&lt;ListNode&gt; q=new PriorityQueue(lists.length, new Comparator&lt;ListNode&gt;()&#123; public int compare(ListNode t1, ListNode t2)&#123; return t1.val-t2.val; &#125; &#125;); 排序对 Collection（List等）排序 1234567//如果list是 5 7 2 6 8 1 4//1、升序：Collections.sort(list) //list： 1 2 4 5 6 7 8//2、降序：Collections.sort(list，Collections.reverseOrder())//list:8 7 6 5 4 2 1//3、逆序；Collections.reverse(list)//list：4 1 8 6 2 7 5 对普通数组排序 1234567int[] a=&#123;5 7 2 6 8 1 4&#125;//1、升序：Arrays.sort(a)//a： 1 2 4 5 6 7 8//2、降序：// 注意！！！！：这里是 Integer[] a Arrays.sort(a，Collections.reverseOrder())//a： 8 7 6 5 4 2 1 文件读写BufferedReader用 readLine() 一次读取一个文本行，如果读到行尾了就返回 null 注意用BufferedReader 要处理异常 123456789101112131415public static void printByFileReaderLine(String filePath) throws IOException&#123; BufferedReader reader=new BufferedReader(new FileReader(filePath)); if(!reader.ready())&#123; System.out.println("文件流暂时无法读取"); return; &#125; int size=0; String line; while((line=reader.readLine())!=null) &#123; System.out.print(line+"\n"); &#125; reader.close();&#125; 需要注意的是：reader.readLine()方法返回的一行字符中不包含换行符,所以输出的时候要自己加上换行符。 关于乱码问题 使用包装InputStreamReader的BufferedReader读取文件 12345678String file = "utf8.txt";BufferedReader reader = new BufferedReader( new InputStreamReader(new FileInputStream(file), "utf-8"));char[] cbuf=new char[20];int size;while((size=reader.read(cbuf, 0, cbuf.length))!=-1)&#123; System.out.println(new String(cbuf,0,size));&#125; BufferedWriter12345678910File file = new File("Hello1.txt");// 创建文件file.createNewFile();// creates a FileWriter ObjectBufferedWriter writer =new BufferedWriter(new FileWriter(file));// 向文件写入内容writer.write("This\n is\n an\n example\n");writer.newLine();//写换行符writer.flush();writer.close(); tips Java 虚拟机将从指定类中的 main 方法开始执行 Java 的所有函数都是属于某个类的方法 Java 中没有无符号形式的 int、double、short 等 char 类型用单引号 声明一个变量之后，必须用赋值语句对变量进行显示初始化，千万不要使用未初始化的变量。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的length,length()和size()]]></title>
    <url>%2F2019%2F08%2F18%2FJava%E4%B8%AD%E7%9A%84length-length-%E5%92%8Csize%2F</url>
    <content type="text"><![CDATA[Java 中判断一个元素的长度一会 size()，一会 length，一会 length()，简直有毒。如何判断用哪个呢？选择这些方法时有什么规律吗？ 1 java中的length属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了length这个属性. 2 java中的length()方法是针对字符串String说的,如果想看这个字符串的长度则用到length()这个方法. 3.java中的size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot连接操作mysql]]></title>
    <url>%2F2019%2F08%2F13%2Fspringboot%E9%93%BE%E6%8E%A5mysql%2F</url>
    <content type="text"><![CDATA[实习过程中需要自己起一个 Springboot 项目并要与 MySQL 交互，第二次更新项目内容时所作记录以防遗忘。 基本的 SpringBoot 知识与 MySQL 都不会介绍。 Maven 配置pom.xml 这里需要添加配置 JPA 和 MySQL connector。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;gs-mysql-data&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- JPA Data (We are going to use Repositories, Entities, Hibernate, etc...) --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Use MySQL Connector-J --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置 application.propertiesSpringBoot 默认的数据库是 H2， 我们可以在application.properties 文件中设定我们所需要的配置。application.properties 文件的目录为src/main/resources/applications.properties。 1234spring.jpa.hibernate.ddl-auto=updatespring.datasource.url=jdbc:mysql://$&#123;MYSQL_HOST:localhost&#125;:3306/db_examplespring.datasource.username=springuserspring.datasource.password=ThePassword 这里spring.jpa.hibernate.ddl-auto可以是 none, update,create,create-drop。 none: 默认值，不会改变数据库结构 update：会根据 Entity(后面会讲)改变数据库结构 create: 每次都会创建新的数据库，关闭时不会删除 create-drop：类似上一个 update 是指在我们设置好Entity后， 如果数据库中没有一个表符合这个 Entity，它会自动创建一个表。所以如果我们数据库中原有我们要操作的表，我们就不需要设置为 update。 创建 Entity创建一个类，设置好各属性，及其 setter 如果需要通过哪项进行查找，如要执行等同 select * where name=xxx 的操作，则要设置该属性的 getter 方法。 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243package hello;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;@Entity // This tells Hibernate to make a table out of this classpublic class User &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO, generator = "native") @GenericGenerator(name = "native", strategy = "native") @Column(name = "id", updatable = false, nullable = false) private Integer id; private String name; private String email; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125; 这种 entity 会被 Hibernate 自动转换进 table 创建 repository创建一个 repository 接口用于之后操作 其默认的方法有限，如果我们希望通过其他属性查找，如通过 name，需要加一个 findByName(String name)方法声明。如果通过两个属性一起查找，则添加 findByNameAndEmail(String name, String email) 在 Entity 中要有气 getter 方法。 1234567891011package hello;import org.springframework.data.repository.CrudRepository;import hello.User;// This will be AUTO IMPLEMENTED by Spring into a Bean called userRepository// CRUD refers Create, Read, Update, Deletepublic interface UserRepository extends CrudRepository&lt;User, Integer&gt; &#123; List&lt;User&gt; findByName(String name); List&lt;User&gt; findByNameAndEmail(String name, String email);&#125; 执行操作通过例子来看 123456789101112131415161718192021222324252627282930313233343536package hello;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;@Controller // This means that this class is a Controller@RequestMapping(path="/demo") // This means URL's start with /demo (after Application path)public class MainController &#123; @Autowired // This means to get the bean called userRepository // Which is auto-generated by Spring, we will use it to handle the data private UserRepository userRepository; @PostMapping(path="/add") // Map ONLY POST Requests public @ResponseBody String addNewUser (@RequestParam String name , @RequestParam String email) &#123; // @ResponseBody means the returned String is the response, not a view name // @RequestParam means it is a parameter from the GET or POST request User n = new User(); n.setName(name); n.setEmail(email); userRepository.save(n); return "Saved"; &#125; @GetMapping(path="/all") public @ResponseBody Iterable&lt;User&gt; getAllUsers() &#123; // This returns a JSON or XML with the users return userRepository.findAll(); &#125;&#125; CrudRepository 接口常用方法继承时，CrudRepository&lt;T, ID&gt; ID 添 ID 的类型 count(): 返回所有 entities 的数量（return long ） save(): 保存该 entity，如果该 entity 是 new 出来的，则是添加新的，如果该 entity 是通过 find 方法得到的引用，则更新该 entity。 delete(T entity) findByID(ID id)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[double类型比较]]></title>
    <url>%2F2019%2F07%2F31%2Fdouble%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[两个 double 类型判断是否相等不能用 d1==d2，这是因为在计算机内部表示小数时（包括 float 和 double 型小数）都有误差。判断两个小数是否相等，只能判断他们之差的绝对值是不是在一个很小的范围里。因此判断需要用一个函数equal(a,b)，这个函数自己写。 1234567public boolean equal(double a, double b) &#123; if ((a- b&gt; -0.000001) &amp;&amp; (a- b) &lt; 0.000001) return true; else return false;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[补码]]></title>
    <url>%2F2019%2F06%2F04%2F%E8%A1%A5%E7%A0%81%2F</url>
    <content type="text"><![CDATA[反码不必多说，直接取反。 那如何求一个二进制数的补码呢？ 先对它进行一次反码，然后再加 1 得到结果。 计算机中存储整数，如果是非负数，直接存其二进制，如果是复数，取其补码储存。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAP定理]]></title>
    <url>%2F2019%2F05%2F29%2FCAP%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[直接看大佬的博客吧。。。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程间通信]]></title>
    <url>%2F2019%2F05%2F29%2F%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[锁机制：包括互斥锁、条件变量、读写锁 互斥锁提供了以排他方式防止数据结构被并发修改的方法。 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量 信号机制(Signal)：类似进程间的信号处理 线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程间的通信]]></title>
    <url>%2F2019%2F05%2F29%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[管道，FIFO，消息队列，信号，信号量，Socket，共享内存。 转载自简书. 进程间通信的概念每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication） 进程间通信的7种方式管道/匿名管道(pipe) 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程); 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。 管道的实质： 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。 该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。 管道的局限： 管道的主要局限性正体现在它的特点上： 只支持单向数据流； 只能用于具有亲缘关系的进程之间； 没有名字； 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）； 管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等； 有名管道(FIFO)匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)。 有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循先进先出(first in first out),对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。有名管道的名字存在于文件系统中，内容存放在内存中。 匿名管道和有名管道总结：（1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。（2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。（3）无名管道阻塞问题：无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。（4）有名管道阻塞问题：有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。 信号(Signal) 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。 如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。 Linux系统中常用信号：（1）SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。（2）SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。（3）SIGQUIT：程序退出信号。程序运行过程中，按Ctrl+\键将产生该信号。（4）SIGBUS和SIGSEGV：进程访问非法地址。（5）SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。（6）SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。（7）SIGTERM：结束进程信号。shell下执行kill 进程pid发送该信号。（8）SIGALRM：定时器信号。（9）SIGCLD：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。 信号来源 信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源： 硬件来源：用户按键输入Ctrl+C退出、硬件异常如无效的存储访问等。 软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。 信号生命周期和处理流程 信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统； 操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。 目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。 消息(Message)队列 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。 与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。 另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。延伸阅读：消息队列C语言的实践 消息队列特点总结：（1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.（2）消息队列允许一个或多个进程向它写入与读取消息.（3）管道和消息队列的通信数据都是先进先出的原则。（4）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。（5）消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。（6）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。 共享内存(share memory) 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。 为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。 信号量(semaphore)信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。 为了获得共享资源，进程需要执行下列操作： 创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。 等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。 挂出一个信号量：该操作将信号量的值加1，也称为V操作。 为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。Linux环境中，有三种类型：Posix（可移植性操作系统接口）有名信号量（使用Posix IPC名字标识）、Posix基于内存的信号量（存放在共享内存区中）、System V信号量（在内核中维护）。这三种信号量都可用于进程间或线程间的同步。 信号量与普通整型变量的区别：（1）信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；（2）操作也被成为PV原语（P来源于荷兰语proberen”测试”，V来源于荷兰语verhogen”增加”，P表示通过的意思，V表示释放的意思），而普通整型变量则可以在任何语句块中被访问； 信号量与互斥量之间的区别：（1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源（2）互斥量值只能为0/1，信号量值可以为非负整数。也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。（3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。 套接字(socket)套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。 套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。 套接字特性套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。（1）套接字的域它指定套接字通信中使用的网络介质，最常见的套接字域有两种：一是AF_INET，它指的是Internet网络。当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用socket作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。另一个域AF_UNIX，表示UNIX文件系统，它就是文件输入/输出，而它的地址就是文件名。（2）套接字的端口号每一个基于TCP/IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留Socket中的输入/输出信息，端口号是一个16位无符号整数，范围是0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。（3）套接字协议类型因特网提供三种通信机制，一是流套接字，流套接字在域中通过TCP/IP连接实现，同时也是AF_UNIX中常用的套接字类型。流套接字提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。二个是数据报套接字，它不需要建立连接和维持一个连接，它们在域中通常是通过UDP/IP协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。三是原始套接字，原始套接字允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW。 原始套接字与标准套接字的区别在于：原始套接字可以读写内核没有处理的IP数据包，而流套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。 套接字通信的建立 服务器端 首先服务器应用程序用系统调用socket来创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，它不能与其他的进程共享。 然后，服务器进程会给套接字起个名字，我们使用系统调用bind来给套接字命名。然后服务器进程就开始等待客户连接到这个套接字。 接下来，系统调用listen来创建一个队列并将其用于存放来自客户的进入连接。 最后，服务器通过系统调用accept来接受客户的连接。它会创建一个与原有的命名套接不同的新套接字，这个套接字只用于与这个特定客户端进行通信，而命名套接字（即原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。 客户端 客户应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。 一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程与线程的区别]]></title>
    <url>%2F2019%2F05%2F29%2F%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[一个任务就是一个进程（Process），在一个进程内部，要同时干多件事情，就需要同时运行多个“子任务”，这些“子任务”称为线程（Thread）。 进程和线程的主要区别在于他们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。所以多进程的程序要比多线程的程序健壮，但在进程切换时，消耗资源较大，效率要差一些。 进程是资源分配的最小单位，线程是程序执行的最小单位。 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。 线程是共享进程中的数据的，使用相同的地址空间，因此 CPU 切换一个线程的花费远比进程要小的多，同时创建一个线程的开销也比进程要小很多。 线程之间的通信更方便，同一进程下的线程共享全局变量，静态变量等数据，而进程之间的通信需要以 IPC（InterProcess Communication) 的方式进行。不过如何处理好同步与互斥是编写多线程程序的难点。 多进程程序更健壮。因为进程有自己独立的空间。 一个进程至少有一个线程，多线程的执行方式和多进程是一样的。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程与线程的简单解释]]></title>
    <url>%2F2019%2F05%2F29%2F%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[转载自阮一峰的网络日志 进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。 最近，我读到一篇材料，发现有一个很好的类比，可以把它们解释地清晰易懂。 1. 计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。 2. 假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。 3. 进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。 4. 一个车间里，可以有很多工人。他们协同完成一个任务。 5. 线程就好比车间里的工人。一个进程可以包括多个线程。 6. 车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。 7. 可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。 8. 一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。 9. 还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。 10. 这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。 不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。 11. 操作系统的设计，因此可以归结为三点： （1）以多进程形式，允许多个任务同时运行； （2）以多线程形式，允许单个任务分成不同的部分运行； （3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于网络的一些基础知识]]></title>
    <url>%2F2019%2F05%2F29%2F%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[包括网络模型，TCP 的三次握手四次挥手，流量控制、拥塞控制以及 HTTP 的一些基础知识点。 网络模型 OSI 七层模型。自下向上：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 TCPIP 四层模型：网络接口层，网际层，传输层，应用层 TCP UDP所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。 四次挥手 A 先说“我不玩了”，进入 FIN_WAIT_1状态，B 接收，发送“知道了”，进入 CLOSE_WAIT 状态A 接收，进入 FIN_WAIT_2状态（等待超时 if B 跑路）B 发送“我不玩了”A 接收，发送回应（ACK），结束 FIN_WAIT_2状态，进入 TIME_WAIT. TIME_WAIT 为两个 MSL（最大报文存活时长） 为什么两个最大报文存活时长 确保最后一个确认报文段能够到达。如果 B 没有收到 A 发来的确认报文段，那么久会重新发送连接释放请求报文段，A 等待一段时间就是为了处理这种情况的发生。 可能存在“已失效的连接请求报文段”，为了防止这种报文段出现在本次链接之外，需要等待一段时间，防止串话。 三次握手 一开始，客户端和服务端都处于 close 状态，先是服务端主动监听某个端口，处于 Listen 状态，然后客户端主动发起建立SYN，处于SYN-SEND 状态，服务端收到发起的连接，返回SYN，并且 ACK 客户端的 SYN，处于SYN-RCVD状态，客户端收到服务端的 SYN 和 ACK之后，发送 ACK 的 ACK，然后处于ESTABLISHED状态。服务端收到 ACK 的 ACK 之后，处于ESTABLISHED状态。 流量控制为了保障顺序性，每一个包都有一个 ID。为了保证不丢包，对于发送的包都要进行应答。但是这个应答也不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这样的模式称为累计确认或者累计应答（cumulative acknowledgment）。 TCP 将所有的包按照 ID 的排列划分： 第一部分，发送了并且已经确认的 第二部分，发送了并且尚未确认的 第三部分，没有发送，但是已经等待发送的 第四部分，没有发送，而且暂时也不会发送 在 TCP 里，接收端会给发送端报一个窗口的大小，叫做Advertised window。这个窗口的大小应该等于上面两个的第二部分加上第三部分。在对包的确认中，同时会携带一个窗口的大小。滑动窗口（rwnd）是怕发送方把接收方缓存塞满。 拥塞控制滑动窗口是怕发送方把接收方缓存塞满，而拥塞窗口（cwnd）是怕把网络塞满。 TCP 的拥塞控制主要来避免两种现象：包丢失和超时重传 慢启动一条 TCP 连接开始，cwnd 设置为一个报文段，一次只能发送一个；当收到这一个确认的时候，cwnd+1，于是一次能够发送两个；当这两个的确认到来的时候，每个确认 cwnd+1，两个确认 cwnd+2，于是一次能够发送四个；当这四个确认到来的时候，每个确认 cwnd+1，四个确认 cwnd+4，于是一次能够发送八个，所以是指数型增长。 涨到什么时候是个头呢，有一个值 ssthresh（slow start threshold） 为 65535 个字节，当超过这个值的时候，就不那么快了。 这时，每收到一个确认后，cwnd 增加 1/cwnd，我们接着上面的过程，一次发送八个，当八个确认到来的时候，每个确认增加 1/8，八个确认一共 cwnd+1，于是一次能够发送九个，变成了线性增长。 但只要增长就会越来越多。直到有一天，水满则溢，出现了拥塞，这时候一般就会一下子降低倒水的速度。 拥塞的一种表现形式是丢包，需要超时重传。这个时候，将 ssthresh 设为 cwnd/2，将 cwnd 设为 1，重新开始慢启动。但这种方式太激进了，将一个高速的传输速度一下子停了下来，会造成网络卡顿。 快速重传算法当接收端发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速的重传，不必等待超时再重传。这时 cwnd=cwnd/2，ssthresh=cwnd，当三个包返回的时候，cwnd=ssthresh+3。 后来还有BBR 拥塞算法，它企图找到一个平衡点，就是通过不断的加快发送速度，将管道填满，但是不填满中间设备的缓存，因为这样延时会增加。 HTTPWhat will happen when you input URL into Browser. Use the URL to get the IP address by submit it to ISP and DMS turn it into IP address New HTTP request is sent including your IP address. the time you sent it and the page you asking for The server get the request. go the database to get the data, compile them into a long html file and send it back to your IP as HTTP response The browser render the page. 方法 GET。GET 就是去服务器获取一些资源。 POST。它需要主动告诉服务端一些信息。要告诉服务端什么呢？一般会放到正文里。（常见格式 JSON） PUT。向指定资源位置上传最新内容。 DELETE。用来删除资源 PS IP 地址是一个网卡在网络世界中的通讯地址，相当于现实世界中的门牌号 无类型域间选路 CIDR （Classless Inter-Domain Routing）xx.xxx.xxx.xx/24 32位中，前24位是网络号 将子网掩码和 IP 地址按位运算AND，就得到网络号 IP 是地址，有定位功能， MAC 是身份证，无定位功能 CIDR 可以判断是不是本地 DHCP 动态主机配置协议]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于数据库的一些基础知识]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[记录一些关于数据库的常考知识点，包括三大范式，锁，MySQL 的 B+树索引 三大范式规范化减少冗余，将具有紧密逻辑联系的属性放到同一个关系中。 函数依赖描述一个关系中属性之间的联系。设 A 和 B 均为关系 R 的属性，若 A 的每个值都和 B 中的一个唯一的值相对应，则称 B 函数依赖与 A，记为 A→B 完全函数依赖假设 A 和 B 是某一关系的属性，若 B 函数依赖于 A，但不函数依赖于 A 的任意一个真子集，则称 B 完全函数依赖与 A。 对于函数依赖A→B，如果去掉 A 的任意一个属性使得该依赖不成立，那么 B 完全函数依赖于 A。 非范式包含一个或多个重复的表 第一范式数据库表中的所有字段值都是不可分解的原子值 第二范式满足第一范式的要求并且每个非主关键字属性都完全函数依赖于主关键字的关系。将第一范式规范化为第二范式是为了消除部分依赖。 第三范式满足第一第二范式并且所有非主关键属性都不传递依赖于主关键字的关系。将2NF 规范化为3NF 需要消除传递依赖。如果存在传递依赖，就将传递依赖的属性移到一个新的关系中，并将这些属性的决定方也复制到该关系中。 ACID 事务的4个基本性质 A, atomicity 原子性：要么全部执行，要么全部不执行 C, Consistency 一致性：事务必须将数据库从一种一致的状态转换到另一种一致的状态。 I, Isolation 隔离性：事务的执行是相互独立的，未完成的事务的中间结果对其他事务是不可见的。 D, Durability 持久性：成功提交的事务的结果要永久的记录在数据库中，不能因为以后的故障而丢失。 锁乐观锁/悲观锁乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。 悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。 乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。 从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。 死锁死锁（Deadlock）就是指两个或两个以上的进程在执行的过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 四个充要条件 互斥条件： 指进程对所分配的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直到占有资源的进程用完后释放资源。 占有且等待条件： 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但它不会释放自己已经占有的资源。 非抢占条件： 指进程已经获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 循环等待条件 存在一个封闭的进程链，使得每个资源至少占有此链中下一个进程所需要的一个资源。 MySQL 数据库索引：B+树我们希望通过索引，查询数据的效率尽可能的高；在存储空间方面，我们希望索引不要消耗太多的内存空间。 大部分数据结构都不支持按区间查找。 B+树由二叉搜索树演化而来。为了让二叉搜索树支持按照区间来查找数据，我们将树中的节点并不存储数据本身，而是只作为索引。除此之外，我们把每个叶子节点穿在一条链表上，链表中的数据是从小到大有序的。改造之后，如果我们要求某个区间的数据，我们只需要那区间的初始值，在树中进行查找，当找到某个叶子节点之后，再顺着链表往后遍历，直到链表中的节点数据值大于区间的终止值为止。 由于数据库中数据量太大，不可能存入内存中，所以我们只能将索引存储在硬盘中，每个节点的读取（或访问）都对应一次磁盘的 IO 操作。那么树的高度就等于每次查询数据时磁盘 IO 操作的次数。 而硬盘的读取速度太慢，所以需要尽可能减少磁盘 IO 操作，也就是降低树的高度。 那么我们将索引构建成 m 叉树就可以减小树的高度。但 m 并不是越大越好。 不管是内存中的数据，还是磁盘中的数据，操作系统都是按页来读取的，一次会读取一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只一次磁盘 IO 操作。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学c++5 函数]]></title>
    <url>%2F2019%2F04%2F26%2F%E9%87%8D%E5%AD%A6cpp%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[关于：形参于实参, 声明, 分离式编译, 数组参数, main 函数参数, 可变参数，默认实参，函数指针 形参与实参函数定义时参数列表里的是形参（parameter），使用函数时，放进圆括号里的是实参（argument）。实参是形参的初始值。 函数的声明因为函数的声明不包含函数体，所以也就无须形参的名字。所以在函数的生命中经常省略形参的名字。 函数声明也称为函数原型 分离式编译分离式编译允许我们吧程序分割到几个文件中去，每个文件独立编译。 如果我们修改了其中一个源文件，那么只需要重新编译那个改动了的文件。这一过程通常会产生的一个后缀名是.obj 或者 .o的文件。后缀名的含义是该文件包含对象代码 (object code)。接下来编译器负责吧对象文件链接到一起形成可执行文件。 123$ CC -c main.cc # generates main.o$ CC -c fact.cc # generates fact.o$ CC main.o fact.o -o main # generate main or main.exe 数组形参123void print(const int*);void print(const int[]);void print(const int[10]); 数组引用形参123void print(int (&amp;arr)[10])&#123; .....&#125; 只能将函数作用于大小为 10 的数组。 传递多维数组首元素本身就是一个数组， 指针就是一个指向数组的指针。数组的第二维的大小都是数组类型的一部分，不能省略。 12345void print(int maxtrix[][10], int rowSize)&#123;&#125;void print(int (*matrix)[10], int rowSize)&#123;...&#125; //matrix 为指向含有 10 个整数的数组的指针int *matrix[10]; //10个指针构成的数组int (*matrix)[10]; //指向含有 10 个整数的数组的指针 main 函数的参数123456int main(int argc, char *argv[])&#123;...&#125;//argv 是一个数组，他的元素是指向 C 风格字符串的指针；argc 表示数组中字符串的数量。//因为第二个形参是数组，所以也可写成：int main(int argc, char **argv)&#123;...&#125;//argv 指向 char* 假设 main 函数位于可执行文件 a 里，我们可以向程序传递下面的选项 1a -d -o ofile data0 此时，argc=5， 123456argv[0]="a";argv[1]="-d";argv[2]="-o";argv[3]="ofile";argv[4]="data0";argv[5]='\0'; 所以用 argv 的实参时要从 argv[1]开始。 可变形参对于实参类型相同的，使用initializer_list标准库类型，需要include &lt;initializer_list&gt;。对于实参类型不同的，使用可变参数模板。 默认实参1int f(int a=1, int b=2)&#123;...&#125; 一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。 函数调用时实参按其位置解析，要想覆盖后面的默认值必须为前面参数提供实参。 当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。 默认实参声明在给定作用域中一个形参只能被赋予一次默认实参，即函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。 默认实参初始值局部标量不能作为默认实参 内联函数 inline调用函数会包含一系列开销，将函数指定为内联函数，则将它在每个调用点上“内联地”展开。从而消除了调用函数的开销。 在函数的返回类型前面加上关键字inline，就可以将它声明为内联函数了。 一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。内联说明只是向编译器发送一个请求，编译器可以选择忽略这个请求。 函数指针函数指针指向某种特定类型，函数的类型由他的返回类型和形参类型共同决定，与函数名无关。 1bool lengthCompare(const string&amp;, const string&amp;); 该函数的类型是bool(const string&amp;, const string&amp;)。 要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可： 1bool (*pf)(const string&amp;, const string&amp;); pf指向一个函数。如果对*pf两端不加括号，那么pf是一个返回值为 bool 指针的函数。 当我们吧函数名作为一个值使用时，该函数自动转换为指针。 函数指针形参直接使用函数指针类型显得冗长而烦琐，类型别名和decltype可以简化函数指针的代码。 1234567// Func and Func2 have function typetypedef bool Func(const string&amp;, const string&amp;);typedef decltype(lengthCompare) Func2;//FuncP and Funcp2 have pointer to function typetypedef bool(*FuncP)(const string&amp;, const string&amp;);typedef decltype(lengthCompare) *FuncP2; decltype返回函数类型，此时不会将函数类型自动转换成指针类型。 返回指向函数的指针我们必须吧返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。要想声明一个返回函数指针的函数，最简单的办法就是使用类型别名 12using F=int(int*, int); //F 是函数类型using PF=int(*)(int*, int); // PF 是指针类型 和函数类型的形参不一会，返回类型不会自动地转换成指针。我们必须显式地将返回类型指定为指针： 12PF f1(int);F* f1(int); 如果我们明确知道返回的函数是哪一个，就能使用 decltype 简化书写函数指针返回类型的过程 12string::size_type f(const string&amp;);decltype(f)* getFcn(const string&amp;, const string&amp;);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学cpp4 数组]]></title>
    <url>%2F2019%2F03%2F26%2F%E9%87%8D%E5%AD%A6cpp-array%2F</url>
    <content type="text"><![CDATA[关于数组的声明，指针与二维数组 复杂的数组声明12345int *ptrs[10]; //ptrs 是一个含有10个 整型指针 的数组int &amp;refs[10]= arr; // Wrong，不存在引用的数组int (*P)[10]=&amp;arr; // P是一个指针，指向一个含有10个整数的数组int (&amp;arrRef)[10]=arr; //arrRef 引用一个含有10个整数的数组int * (&amp;arr)[10]=ptrs; //arr 是数组的引用，该数组含有10个指针 指针与数组123456string nums[]=&#123;"onr", "two", "three"&#125;;string *p=nums; // string *p=&amp;nums[0];auto p2(nums); //p2为指向字符串的指针，指向 nums 的第一个元素auto p2(&amp;nums[0]);*p2="sfa"; 当用decltype时，跟上面又不一样了，不再返回指针，而是返回数组 123int ia[]=&#123;1,2,3,4,5,6,7,8,9,0&#125;;decltype(ia) ia2=&#123;0,1,2,3,4,5,6,7,8,9&#125;; //decltype 返回的类型是由10个整数构成的数组 把指针当迭代器重点在于找到终止点。 12345int *e=&amp;arr[10]; //指向 arr 最后一个元素的下一个位置。for(int *b=arr; b!=e; ++b)&#123;&#125;// orint *e=end(arr); //#include &lt;iterator&gt;int *b=begin(arr); //This is better 二维数组初始化 1234567int a[3][4]=&#123; &#123;0,1,2,3&#125;, &#123;4,5,6,7&#125;, &#123;8,9,0,1&#125;&#125;;int a[3][4]=&#123;0,1,2,3,4,5,6,7,8,9,0,1&#125;; //same PS数组不能被拷贝]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学c++3 decltype & string]]></title>
    <url>%2F2019%2F03%2F25%2F%E9%87%8D%E5%AD%A6cpp-decltype-and-string%2F</url>
    <content type="text"><![CDATA[关于decltype 和 string 的一些东西。 decltype返回方程的返回类型。 三 decltypedecltype的作用是选择并返回操作数的数据类型 12345decltype(f()) s=x; //s 的类型为函数 f 的返回值类型const int c1=0, &amp;c2=c1;decltype(c1) x=0; //const int xdecltype(c2) y=x; //const int &amp;y=x; 如果 decltype 的表达式加上了一对括号，这样的 decltype 会得到一个引用类型 12int i=0;decltype((i)) d=i; // d是一个 int&amp; 引用变量 四using 声明123using namespace::name;using std::cin; 头文件的代码一般不能使用 using 声明，因为头文件的内容会拷贝到所有引用他的文件中去。 Stringgetline 函数在最终得到的字符串中保留输入时的空白符getline(ins, s) 第一个参数是输入流，第二个参数是 string。函数从输入流中读入内容，直到遇到换行符为止。 输入运算符作为判断条件1while(cin&gt;&gt;value) cin&gt;&gt;value 返回 cin，一个istream 对象。当使用istream对象作为判断条件时，效果是检测流的状态。当遇到文件结束符或一个无效的输入时，判断为假。123456int main()&#123;string line; while(getline(cin, line)) cout&lt;&lt;line&lt;&lt;endl; return 0;&#125; string 相加当把 string 对象和字符字面值及字符串字面值混在一条语句中使用，必须确保每个加法运算符的两侧的运算对象至少有一个是 string1234string s4=s1+","; //rightstring s5= "hello"+","; //wrongstring s6=s1+","+"hjello"; //rightstring s7="hello"+","+s1; //wrong 处理字符123456789#include &lt;cctype&gt;isalnum(c)isalpha(c)isdigit(c)islower(c)isupper(c)isspace(c)tolower(c)toupper(c)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学C++2 const]]></title>
    <url>%2F2019%2F03%2F17%2F%E9%87%8D%E5%AD%A6cpp-const%2F</url>
    <content type="text"><![CDATA[指向常量的指针，常量指针，指向常量的常量指针 = =！ const默认状态下，const对象只在文件内有效。如果只在一个文件中定义 const，而在其他多个文件中声明并使用它，那么对 const 变量不管是声明还是定义都添加extern 关键字。1234//file.cc中定义并初始化extern const int a=1;//file.h 中声明extern const int a; //这俩 a 是同一个 对常量的引用（reference to const） 123const int c1=1;const int &amp;r1=c1;int &amp;r2=c1; //错误，非常量引用不能指向常量 指向常量的指针 要想放常量的地址，只能用指向常量的指针。123const double pi=3.14;double *p1=&amp;pi; // WRONG!const double *p2= &amp;pi; //Right const 指针允许吧指针本身定义为常量，常量指针（const pointer）必须初始化。把*放在 const 之前，来说明指针是一个常量，此时不变的是指针本身，而不是指针指向的值。1234int num=0;int *const p=&amp;num; // const pointer，p 不能改，（*p)可以改const double pi=3.14;const double *const p2=&amp;pi; 弄清声明含义可以从右向左读。 顶层 const &amp; 底层 const顶层 const 可以表示任意的对象是常量（如表明指针本身是一个常量），而底层 const 表示指针所指的对象使一个常量。 常量表达式 const expression常量表达式是指值不变并且在编译过程就能得到计算结果的表达式。 C++11允许将变量声明为 constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为 constexpr 的变量一定是一个常量，而且必须用常量表达式初始化。（还有 constepr 函数，在编译时计算出结果）。 在 constexpr 声明中如果定义了一个指针，限定符 constexpr 仅对指针有效，与指针所指的对象无关。 12345const int *p=nullptr; //一个指向整型常量的指针constexpr int *q=nullptr; //一个指向整数的常量指针constexpr int i=0;constexpr const int *pp=&amp;i; //指向常量的常量指针 类型别名类型别名是一个名字，是某种类型的同义词。有两种方法。 1.typedef12typedef double wages; //wages 就是 doubletypedef wages base, *p; // base 就是 double，p 是 double *的同义词 2.别名声明1using SI=int; 坑：如果某个类型别名指代的是复合类型或常量，结果跟你想的可能不太一样。 123typedef char *pstring; //pstring 是 char * 别名const pstring cs=0； // cs 是指向 char 的 “常量指针”！不是指向常量字符的指针const pstring *p; //p是一个指针，他的对象是指向 char 的常量指针]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学 C++]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%87%8D%E5%AD%A6%20cpp%2F</url>
    <content type="text"><![CDATA[之前学的不够扎实，更加系统、贴近底层的学一遍。非新手笔记，都是比较基础的东西，但没有最最基础的东西 零main 函数的返回类型必须是int，返回 0 表明成功。 curly brace 花括号 block of statements 语句块 assignment 赋值 windows: .\表示该文件在当前目录中，Unix: ./ 表示可执行文件在当前目录中。 stream：流，一个流就是一个字符序列。随着时间的推移，字符是顺序生成或消耗的。 cin cout cerr clog &lt;&lt; 输出运算符，返回其左侧的运算对象 endl是一个被称为操作符(manipulator)的特殊值，写入endl的效果是结束当前行，并将于设备关联的 buffer 中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。 :: 作用域运算符 &gt;&gt; 输入运算符，返回左侧运算对象 当用一个istream 对象作为判断条件时，其效果是检测stream 的状态。当流未遇到错误，即为true。但遇到文件结束符（ctrl+D in Mac）或遇到无效输入，状态变为无效，条件为 false。 文件重定向 将标准输入和标准输出与命名文件关联起来。1$ addItems &lt;infile&gt;outfile addItem 为编译后的可执行文件，上述命令会从一个名为 infile 的文件读取销售记录，并将输出结果写入一个名为 outfile 的文件中。123456789#include&lt;iostream&gt;#include "Sale_item.h"int main()&#123; Sale_item item1, item2; std::cin&gt;&gt;item1&gt;&gt;item2; std::cout&lt;&lt;item1+item2&lt;&lt;std::endl; return 0;&#125; 一可寻址的最小内存块称为 字节 (byte)，存储的基本单元称为 字 (word)，一个字节由八个比特（bit）构成，一个字由32或64比特构成。 char 8位（bits），一字节（bytes） int 32位，四字节 float ，32位，6位有效数字 double 64位，10位有效数字 char16_t &amp; char32_t 为 Unicode 字符 short 16bits long 32 bits long long 64 bits long double 96 or 128 bits 0开头为八进制，0x 开头十六进制 执行浮点数运算选用 double， 因为 float 通常精度不够，而且双精度浮点数和单精度浮点数的计算代价差不多。 勿混用有符号类型与无符号类型如果 int 和无符号运算，那么 int 值会自动转变为无符号数。 当从无符号数中减去一个值时，不管这个数是不是无符号数，我们都必须确保结果不能是一个负值。 1234unsigned int u1=42,u2=10;cout&lt;&lt;u2-u1&lt;&lt;endl;输出：4294967264 浮点数科学计数法表示：指数部分用 E 或 e 标识: 24E2->2400 引用（reference）为对象起了另外一个名字，引用必须被初始化。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。即定义了一个引用后，对其进行的所有操作都是在与之绑定的对象上进行的。 空指针不指向任何对象，在试图使用一个指针之前代码可以先检测它是否为空。123int *p1=nullptr; // &lt;--- bestint *p2=0;int *p3=NULL; //#include &lt;cstdlib&gt; 把 int 变量直接给指针是错误的，即使该值是0。 指向指针的引用 12345int i=42;int *p;int *&amp;r=p; // r 是一个对指针 p 的引用r=&amp;i; // p 指向 r*r=0; 从右向左阅读 r 的定义，首先是&amp;，说明 r 是一个引用，其次是*，表示 r 引用的是指针，最后int，r 引用的是 int 指针。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++函数的参数的不同传递方式]]></title>
    <url>%2F2019%2F03%2F01%2FC-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[面试要用 C++，没用 C++写过任何 project， 从头开始学 妈耶可烦死我了。 刷题时看到关于 C++函数的参数传递有好多形式，有直接传的，有传指针的，还有传&amp;，最后一个没怎么见过。找了些资料，发现这些对应的是值传递，指针传递和引用传递。 在这个博客找到了非常深入的解释，摘抄部分如下： （注：函数中用于接收传递值的变量叫形参，传递给函数的值叫实参） 值传递： 形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-&gt;形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。1void f1(int n)&#123;n++;&#125; // 外面传来的 n 不变 指针传递： 形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作1void f2(int *n)&#123;*n=*n+1;&#125; //外面的 n 也变 引用传递： 形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。 12345void f3(int &amp;n)&#123;n++;&#125; ////外面的 n 也变//对引用传递，传入的时候只是传 n，不同于指针传 &amp;nint n=2;f3(n);]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github page自定义域名的 ip 过时]]></title>
    <url>%2F2019%2F02%2F17%2Fgithub%20page%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E7%9A%84%20ip%20%E8%BF%87%E6%97%B6%2F</url>
    <content type="text"><![CDATA[今天改博客的时候，每次部署都会收到 github 的邮件说： The custom domain for your GitHub Pages site is pointed at an outdated IP address. You must update your site’s DNS records if you’d like it to be available via your custom domain. 因为现在 github page 现在的ip换了，之前自己的域名绑定的ip 不再试用。 解决之道： 登录自己的域名管理网站（我的是托管到 DNSPOD 上的），将之前的 ip 为192.30.252.153的关掉，添加 185.199.108.153]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习笔记2]]></title>
    <url>%2F2019%2F02%2F17%2Fpython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[接上部 位操作符 Othereval( )eval() 函数用来执行一个字符串表达式，并返回表达式的值。 range( ) 倒序range(a,b,-1) enumerate( ) 函数enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中. 12345678910111213&gt;&gt;&gt;seasons = ['Spring', 'Summer', 'Fall', 'Winter']&gt;&gt;&gt; list(enumerate(seasons))[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]&gt;&gt;&gt; list(enumerate(seasons, start=1)) # 下标从 1 开始[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]&gt;&gt;&gt;seq = ['one', 'two', 'three']&gt;&gt;&gt; for i, element in enumerate(seq):... print i, element...0 one1 two2 three filter( ) 函数filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 list() 来转换。 该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。 12345678910#!/usr/bin/python3def is_odd(n): return n % 2 == 1tmplist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])newlist = list(tmplist)print(newlist)&gt;&gt;&gt;[1, 3, 5, 7, 9] zip( ) 函数zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。return min((b-a) for a, b in zip(m, m[1:])) divmod( )函数python divmod() 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。 join( ) 函数‘s’.join(str)s: 分隔符，可以为空str：要连接的元素序列、字符串、元组、字典上面的语法即：以sep作为分隔符，将seq所有的元素合并成一个新的字符串 返回值：返回一个以分隔符sep连接各个元素后生成的字符串 __contains__在类中定义，在外面当用到 for i in class 时，in 调用该函数in = contains()x.__contain__(y)&lt;==&gt; y in x Importcollections.CounterCounter类的目的是用来跟踪值出现的次数。它是一个无序的容器类型，以字典的键值对形式存储，其中元素作为key，其计数作为value。 12&gt;&gt;&gt; c = Counter() # 创建一个空的Counter类&gt;&gt;&gt; c = Counter('gallahad') # 从一个可iterable对象（list、tuple、dict、字符串等）创建 collections.dequedeque 是双边队列 1234567891011d = collections.deque([])d.append('a') # 在最右边添加一个元素，此时 d=deque('a')d.appendleft('b') # 在最左边添加一个元素，此时 d=deque(['b', 'a'])d.extend(['c','d']) # 在最右边添加所有元素，此时 d=deque(['b', 'a', 'c', 'd'])d.extendleft(['e','f']) # 在最左边添加所有元素，此时 d=deque(['f', 'e', 'b', 'a', 'c', 'd'])d.pop() # 将最右边的元素取出，返回 'd'，此时 d=deque(['f', 'e', 'b', 'a', 'c'])d.popleft() # 将最左边的元素取出，返回 'f'，此时 d=deque(['e', 'b', 'a', 'c'])d.rotate(-2) # 向左旋转两个位置（正数则向右旋转），此时 d=deque(['a', 'c', 'e', 'b'])d.count('a') # 队列中'a'的个数，返回 1d.remove('c') # 从队列中将'c'删除，此时 d=deque(['a', 'e', 'b'])d.reverse() # 将队列倒序，此时 d=deque(['b', 'e', 'a']) collections.defaultdict( )免去查看字典里是否有 key 的操作，如果没有直接加上 123456789101112# 普通 dictionarygraph=&#123;&#125;for u, v, w in times: if u not in graph: graph[u]=[(v, w)] else: graph[u].append((v, w))# 骚操作graph=collections.defaultdict(list)for u, v, w in times: graph[u].append((v,w)) heapq最小堆（优先队列）123456789101112131415161718192021222324252627282930&gt;&gt;&gt; l=[4,2,5,7,1]&gt;&gt;&gt; heapq.heapify(l)&gt;&gt;&gt; l[1, 2, 5, 7, 4]&gt;&gt;&gt; h=[] #定义一个list&gt;&gt;&gt; import heapq #引入heapq模块&gt;&gt;&gt; h[]&gt;&gt;&gt; heappush(h,5) #向堆中依次增加数值&gt;&gt;&gt; heappush(h,2)&gt;&gt;&gt; heappush(h,3)&gt;&gt;&gt; heappush(h,9)&gt;&gt;&gt; h #h的值[2, 5, 3, 9]&gt;&gt;&gt; heappop(h) #从h中删除最小的，并返回该值2&gt;&gt;&gt; h[3, 5, 9]&gt;&gt;&gt; h.append(1) #注意，如果不是压入堆中，而是通过append追加一个数值&gt;&gt;&gt; h #堆的函数并不能操作这个增加的数值，或者说它堆对来讲是不存在的[3, 5, 9, 1]&gt;&gt;&gt; heappop(h) #从h中能够找到的最小值是3,而不是13&gt;&gt;&gt; heappush(h,2) #这时，不仅将2压入到堆内，而且1也进入了堆。&gt;&gt;&gt; h[1, 2, 9, 5]&gt;&gt;&gt; heappop(h) #操作对象已经包含了11 函数式编程高阶函数 f=abs 函数本身可以赋值给变量，即变量可以指向函数。既然变量可以指向函数，函数的参数能接受变量，那么一个函数就可以接受另一个函数作为参数，这种函数就称之为高级函数 mapmap() 函数接受两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，，并把结果作为新的Iterator返回。 123456789&gt;&gt;&gt; def f(x):... return x * x...&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))['1', '2', '3', '4', '5', '6', '7', '8', '9'] 感觉这个跟 filter( ） 有点像啊，filter( )接受一个是函数，一个是 list，返回一个迭代器，将返回 True 的放进去。 reduce 函数reduce( )把一个函数作用在一个序列上，这个函数必须接受两个参数，reduce吧结果继续和序列的下一个函数做累积计算。 123456789101112131415reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def add(x, y):... return x + y...&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])25&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def fn(x, y):... return x * 10 + y...&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])13579 sorted( ) 函数他可以接受一个key函数来实现自定义排序。 12&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)[5, 9, -12, -21, 36] 还可反向排序，传入第三个参数： reverse=True 12&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)['Zoo', 'Credit', 'bob', 'about'] 匿名函数 lambda x: x+x]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习笔记1]]></title>
    <url>%2F2019%2F02%2F09%2Fpython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[如果要让 Python 打印出指定的文字，可以用print( )，把打印的文字用单引号或双引号括起来。 input( )函数输入，input 返回的数据类型是 str # 开头的是注释 数据类型 整数 浮点数 正负无穷 float(&quot;inf&quot;) and float(&quot;-inf&quot;) 字符串 字符串是以单引号‘或双引号“括起来的文本。 还可以用r&#39; &#39;表示&#39; &#39;内部不转义。 12print(r&apos;\\\t\\\&apos;)&gt;&gt;&gt; \\\t\\\ [] list；( ) tuple； 方法：append( ), pop( ), insert( a, b) { }dictionary dic[’a’]=b dic.pop(&#39;a&#39;) set: key 的集合 但不存储value。 创建一个 set 需要提供一个 list 作为输入集合。 方法：add(key), remove(key), set 可以看成数学意义上的无序和无重复元素的集合 list 方法 l.count(1) 值为1的有几个 b=a[:] make a copy! string 方法 set 方法 dictionary 方法 dic.pop(key) 大小写12345678910str="www.zhstark.com"print(str.upper() )# 把所有字符中的小写字母转换成大写字母print(str.lower() ) # 把所有字符中的大写字母转换成小写字母print(str.capitalize() ) # 把第一个字母转化为大写字母，其余小写print(str.title() ) # 把每个单词的第一个字母转化为大写，其余小写WWW.RUNOOB.COMwww.runoob.comWww.runoob.comWww.Runoob.Com 判断是否是数字或字母12345678str 是字符串str.isalnum() #所有字符都是数字或者字母str.isalpha() #所有字符都字母str.isdigit() #所有字符都是数字str.islower() #所有字符都是小写str.isupper()str.istitle() #所有单词都是首字母大写str.isspace() #所有字符都是空白字符、\t、\n、\r 格式化12345678&gt;&gt;&gt; 'hello, %s' % 'world'hello, world'&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Micheal', 99999)%d 整数%f 浮点数%s 字符串%x 十六进制整数 函数定义一个函数要使用的饭语句，依次写出函数名，括号，参数和冒号： 定义一个什么也不做的空函数，可以用 pass 语句：12def nop(): pass pass可以用来做占位符 位置参数 def power(x): 默认参数 def power(x, n=2): 可变参数 def calc(*number): 参数 number 接收到的是一个 tuple 关键字参数 def person(name, age, **kw): 命名关键字参数 def person(name, age, *, city, job): def person(name, age, *args, city, job): 命名关键字参数必须传入参数名。 特性切片123L[0:3]L[:3]L[-2:] 迭代我们可以通过 for 循环来遍历一个 list或 tuple，这种遍历我们称为迭代 ( Iteration )内置的 enumerate 函数可以把一个 list 变成索引-元素对 12for i, value in enumerate(['A','B','C',]): print(i, value) 列表生成器1[k*k for k in range(1,11)] 生成器一边循环一边计算的机制，称为生成器：generator。可以通过next()函数获得 generator 的下一个返回值。 第一种方法，把列表生成式的[] 改成()，就创建了一个 generator g=(x*x for x in range(10)） 第二种方法，如果一个函数定义中包含yield关键字，那么这个函数就不再是普通函数，而是一个 generator。 1234567def fib(max): n,a,b=0,0,1 while n&lt;max: yield b a,b=b, a+b n=n+1 return 'done' 迭代器可以被 next() 函数调用并不断返回下一个值得对象成为迭代器： Iterator。把 list, dict, str 等 Iterable 变成 Iterator 可以使用 iter() 函数： 12&gt;&gt;&gt; isinstance(iter('abc'), Iterator）True]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七牛图床链接失效]]></title>
    <url>%2F2018%2F12%2F19%2F%E4%B8%83%E7%89%9B%E5%9B%BE%E5%BA%8A%E9%93%BE%E6%8E%A5%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[突然发现以前博客的图片都没有了，查了一下是因为七牛的连接更改问题（我之前用的都是七牛的图床）。 找了个弥补方法的链接。懒得吧图片折腾回来了，反正也没人看=。= 在七牛新建一个存储空间还能继续用，希望七牛不要出这种幺蛾子了吧。]]></content>
      <categories>
        <category>记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git push 重新输入密码]]></title>
    <url>%2F2018%2F12%2F17%2Fgit%20push%20%E9%87%8D%E6%96%B0%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[第一种情况通过 https:// clone 下来的，输入：git config --global credential.helper store 网上普遍推这种方案，但我没试过 这种方案的缺点在于账户密码完全明文存储在本地，不安全。 第二种情况通过SSH clone 下来的，但每次 git push 仍要输入密码。 首先检查根目录下有没有 .ssh 文件 如果有，运行 1ssh-add -K ~/.ssh/id_rsa 没有， 12345678ssh-keygen -t rsa -C "email@mail.com"git config --global user.name "name"git config --global user.email "email@mail.com"#测试ssh -T git@github.com]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加路径到 PATH 的问题]]></title>
    <url>%2F2018%2F10%2F18%2F%E6%B7%BB%E5%8A%A0%E8%B7%AF%E5%BE%84%E5%88%B0%20PATH%20%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[该文章是记录我在捣鼓 pandoc 的时候出现 bug 并解决的过程。 由于我平时喜欢用 markdown 写作，如何编辑数学公式就成了难题。通过 pandoc，我可以在 markdown 里用 LaTeXiT 编辑公式，通过 pandoc 就可以导出显示公式的 pdf 了。但在我导出的时候，会有提示pdflatex not found. pdflatex is needed for pdf output.。我之前已经下载过 MacTex，所以pdflatex这东西我是一定安装好了，通过搜索，发现应该是路径没有导入 PATH 的问题。但是网上的教程对我来说并不管用，通过一系列折腾，终于搞清楚了问题所在。 当我们安装了新的底层程序（如 MacTex，npm），需要将其路径放到 PATH 中，在很多网络教程中，都是使用的该语句： 1sudo nano /etc/paths 将路径输入进文件，或者是： 1echo 'export PATH="/usr/local/bin:$PATH"' &gt;&gt; ~/.bash_profile 然后用echo $PATH 查看，在某些情况下，该PATH 变量并没有任何改变，打开/etc/paths 文件，看到路径确实添加进去了。这是怎么回事呢？ 这时候echo $PATH 所显示的路径其实属于 bash_profile，我们用文本编辑器打开该文件，看到里面有1export PATH="/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin" 我们只需要将所要添加的路径续在&quot; &quot; 后面就可以了，记得用:与前面的路径分开。eg：export PATH=&quot;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/Library/Tex/texbin&quot;然后重启终端，再用echo $PATH，就发现已显示添加的路径。]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中科院科研项目总结]]></title>
    <url>%2F2016%2F10%2F09%2F%E4%B8%AD%E7%A7%91%E9%99%A2%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前三部分为扯淡，第四部分描述了这个课题的过程步骤，第五部分为一些小感悟，第六部分是小福利。 先扯扯淡 一为期五天的科研营结束了，有收获，也有遗憾。 这五天确确实实学到了很多东西，不论是概念上的，还是方法、工具使用上的。终于大致理解了机器学习有哪些方法，基于的原理，并切实应用了 SVM 分类器。大二调了一年参数，本以为会了机器学习就可以让电脑自己搞出成果来，结果还是要自己再去调参数，真是蛋疼。 基于各种原因，最终我们并没有切实的完成这个课题，目前只是从一幅图片里提取出了车牌的区域，还不能让电脑认识车牌上的字符，写入文本。日后要补完，最好再整理重构一下。（一不小心就立了 flag = =） 短短五天，除了第一天，每天都是凌晨一点多才能睡。第二天9点上课，中午没有午休，却从没有像在学校一样听着课不小心就睡着。也许是老师讲课水平高，也许是这些知识确确实实吸引了我，激起了我的兴趣，总之，在这种强度下没有出现过上课睡着的情况甚至连打瞌睡都没有，对我来说，史无前例。 二最后一天，走前在计算所里面简单逛了逛，发现其一楼布置的还是很赞的。内部有买咖啡的地方，应该是因为在假期吧，里面无人营业。 咖啡店外面，提供了好长一排可以读书讨论的地方，沙发座椅，环境布置的很不错。 我认为一个公司（/机构）里的厕所设置可以在很大程度上代表该公司（/机构）的硬件水平。不得不说计算所的厕所设置的还是很人性化的，至少在我所见过的建筑中，计算所的最贴心。内部采取的是人体红外感应，水龙头的距离感应特别靠谱，不像其他地方的要晃半天手才感应到。每个厕间都有放东西的小托盘，有厕纸。暖暖的，很贴心。 好久之后才发现，原来大名鼎鼎的搜狐就在旁边 三这次做东西最开心的莫过于终于不用 TMD 开虚拟机用 Windows了！不知要剩多少心，感觉自己又能多活五分钟。以后选专业就要选这种能全程使用 Mac，不像搞单片机那样离开 Windows 就 gg，Mac 给我的美感，舒适能让我坚持更长时间的工作( ⸝⸝⸝⁼̴́⌄⁼̴̀⸝⸝⸝)。工具嘛，必须用顺手的才有效率。 可惜的是没有带转接头，无法用自己电脑，展示PPT的时候只能讲Keynote 转为 pdf格式了。 四 以上都是扯淡以下来稍微专业点的干货有时候我会提出一些简单的问题，有兴趣的读者可以思考一下 认识个车牌看似简单，但是要把这个检测识别做的足够强大，有更强的普适性，还是有很多工作要做的。单是对鱼眼镜头图像的校正处理就能发硕士毕业论文了。目前做的没那么复杂，只是对正视视角的车牌处理。但还是会分割为好多问题。 得到一幅图像，我们要通过一定的方法找到可能是车牌的区域，即选择符合一定规则的框框，作为车牌的“候选人”，下一步，便是在这些“候选人”中选择最合适的人选，即找出真正的带车牌的框框。该人选可能没有那么了解当前的业务，所以，下一步便是对选好的人选进行培训，即对所选的车牌区进行进一步优化处理，以便进一步识别出上面的字。最后，就是把一个字一个字都扣下来，进行模板匹配，从而将车牌上的字从“图像”的印象转为“字符”的印象。这是目前所差的步骤了，当然，在完成的过程中肯定还会遇到各种各样的问题，已经习惯麻木了_(:3」∠)_ 4.1读取图像就是从文件里找，当时老师要求做一个简单的 GUI 界面，我一脸懵逼的就去学做 GUI了，结果其实只需要一个内带的函数就可以自动跳出 GUI 界面让你选择文件。 4.2可能是车牌的区域怎么找嘞？方法很多，我们目前用了两种，第一种是通过颜色提取，因为车牌是蓝色的嘛（暂时只考虑蓝色车牌），那么只需要把蓝色的区域提取出来就是嫌疑牌喽。怎么提取呢？一张彩图是通过几个通道的数据合成出来的。比如 RGB 的图片格式，就是通过 R(red), G(green), B(blue)三个代表三种颜色的通道合成出来的。如果是 RGB 的图片格式的话，我们就可以选择 R G 通道数字小，B 通道在一定范围的区域作为嫌疑牌。不过目前我使用的是 Lab格式，测试过 hsv格式，效果不好。没有测试 RGB格式。找到嫌疑牌后，我们就把这张图片二值化，即把嫌疑牌说占的区域全部变成白色，其他变成黑色。（为什么要二值化呢？） 第二种就是通过轮廓提取，对于一张灰度图来说，色差明显的地方我们可以视为边缘。这一步便是先利用 RGB 变灰度的经验公式对彩图进行灰度化，然后通过一定的算法对该灰度图提取边缘。（为什么不直接对彩图提取边缘呢？）提取后，凡是边缘的地方就是白色，不是边缘的就是黑色。因为车牌是白边蓝底白字，所以这种方法把车牌选中的难度不大。 4.3现在我们得到了一张只有黑白两种颜色的图片，那，来回答为什么对通过颜色提取的图片进行二值化的问题。是为了和轮廓提取法相统一吗？通过轮廓提取就是二值化后的了。并非如此。二值化是为了方便我们的这一步处理。 因为只有黑白两种颜色，所以处理起来自然简单的多。所以这也是我们化简问题的一种方法。 对于得到的黑白图像，我们再对其做“腐蚀”或“膨胀”或既有“腐蚀”又有“膨胀”的处理（图像处理上的专业术语，放张图片感受下）。相当如对图片的一步润色。 不管是是通过轮廓还是颜色，对选的嫌疑牌的大小，形状都没有限定。所以有可能有很多小的零散的点，类似于噪声，总之那些一定是对我们没用的东西，所以我们再把那些特别小的点除去，这样，我们就得到了质量更高的嫌疑牌。（类比于海选第二阶段，在淘汰掉一群倒霉孩子） 4.4海选结束，我们得到了少数几个很有可能是车牌的区域，当然，我们需要的是他们的坐标信息。从而在原图像中把这些区域扣出来。 下一步，就是把真正的车牌选出来，这一步也是这个课题最有趣的部分。它需要用到机器学习的方法，让机器学着认识车牌。 机器毕竟不是人，它算的再快也没用像人类一样的抽象思维，它只能处理数字信息。那么如何让电脑认识车牌就是一个大问题。 既然电脑认识数字信息，那么我们就从图片上提取出数字信息呗。这项课题中我们便是提取图片的 HOG（histogram of gradient）特征。记住了一个图像的 HOG特征之后，那电脑就认识这幅图像了。 但是，你认识了这副图，下一幅类似的不认识了也不行啊，不能只认识黑体的“1”转为斜体“1”就一脸懵逼呀。 这时候，就要用到强大的 SVM分类器了。这一块之前的文章有过介绍，有兴趣的也可以网上查找资料，不再赘述罢。一句话：「把”是车牌”的 HOG特征和”不是车牌”的 HOG特征输入电脑，电脑以后就知道”啥样的是车牌，啥样的不是车牌”了。」 这样一来，我们把之前选好的嫌疑牌送给电脑，电脑就认得这些嫌疑牌中的真车牌了。 4.5这时候我们得到了的带车牌的区域，而我们最终的目的是要识别出上面的字。所以我们还有对这块区域进行进一步处理，方便我们更容易认识上面的字。 如果这时候的车牌是有小倾角的，我们对其进行 radon变换，将其摆正。然后再对其进行削边，凡是不包括字符的区域全部丢掉，丢掉！ 终于，我们得到了包含字符的最小区域。也是我目前做到的阶段。再下一步，就是认出上面的字了。 4.6电脑不够机灵，多个字放一起它认不得，得把单个的字分离出来，然后对每个字进行模板匹配，从而达到认识字的目的。这一部分等我完成再写，没有实际操作，纸上谈兵不靠谱。 五做这个项目有哪些感悟呢？ 第一个是「维度」的概念，在 SVM 分类器中，对一个较复杂的情形做线性分割的方法便是「升维」。升到更高的维度后观察，非线性关系就转变为了线性关系，很多问题就可以轻易地解决了。就像我们身处三维空间就能很容易的解决二维平面的问题，而对三维空间中的物体处理起来却有时候力不从心，对四维空间中的东西……等等，什么四维空间？ 第二个是「换位思考」，「换位思考」不仅仅是指与人换位，还可以与机器换位。在这个项目便是试着按照计算机的处理特点去思考。计算机没有感性思维，他只能处理数字信息，那如何才能让计算机像人类一样呢？我们就试着把我们说看到的东西转换为数字信息，一张张图片不就是一个个二维或三维的数组嘛，我们看到的什么颜色又对应数组中怎样的数值？试着从计算机的视角去看待事物，找到计算机与人相连接的桥梁，我们就知道如何让计算机像人一样看待事物了。 第三个是「搜索引擎是亲爹」。这个项目没有规定教材，不会的知识全靠网上搜，Google 百度用起来。我们处于「学习」阶段，不同于「研究」，我们遇到的问题之前都有还多人遇到过，我们走的路之前很多人也走过，所以，在这个阶段，互联网上有大量的资源可以帮助我们解决问题，搜一下就能找到，方便快捷。所以，检索能力很重要。 第四，「数学就是亲爷爷」。 六这个项目我一定会完成，但是时间不好说，两周一个月都有可能。如果你对此有兴趣，可以回复“「车牌识别」+（你的邮箱）”，当我完成的时候会把全部代码上传到 github，并发邮件通知你 :）]]></content>
      <categories>
        <category>Proactive</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中科院科研项目第三天]]></title>
    <url>%2F2016%2F10%2F04%2F%E4%B8%AD%E7%A7%91%E9%99%A2%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[一今天晚上终于找到一家合适的咖啡店上自习，有网，安静。中科院不提供自习处，十一假期好多店又关门，每天晚上我们都是无家可归的状态，到处找地方蹭网做作业。而且，这家店老板的闺女挺漂亮哒，态度好，声音也好听，嘤嘤嘤。 项目一共五天，今天已经是第三天了，还有两天结束，周围开门的饭店已经被我吃遍了。。。。感觉每逢短期假期就是我遭罪的时候，不回家，然而在外面各个服务业又停业，没地方吃，没地方去，只有床才是最温暖的陪伴。 二今天的作业是利用 HOG 提取体特征，将训练集送入 SVM 分类器让其学习，产生一个模型，再利用学习后的模型对我们需要分类的样本进行分类。 HOG 我还没太仔细看，解释不清楚，至于 SVM，可以看我上一篇文章最后的 gif 录屏，不要嫌那个动的太快，腾讯只让发2M 以下的 gif，我也没办法。其实只要我们上下摆头的速率和那张动图变化的速率一样，就能看清了。不难，我试了7次就合上拍了，还挺清晰的。 就我们目前做的课题来说，就是送一堆车牌的图片给电脑，并告诉他「看清楚了，这是车牌！」再送给他一坨不是车牌，但他可能以为是车牌的图片，告诉他「长点即兴，要是认错了发你跪键盘！」然后电脑就赶紧认认真真地去学习车牌长什么样子，不长什么样子。 等他学会后，吸收，消化，排泄，拉出一个模型便便💩，不屑地告诉我「我这便便能认识车牌了，你把这便便扣在有车牌的图片上，它把车牌给你熏下来。」 我如珍似宝地双手托着这宝贵的便便，使劲扣在一张图片上，它还真把车牌给熏下来了。我熏了一张又一张，发现，这便便味道不够足嘛，有的车牌还是熏不下来，唉。回去罚他跪键盘，但是发现作为一个穷逼，我并没有键盘让他跪。所以特此征好心人送我一个 cherry 键盘来让电脑跪，感激不尽。 三其实让电脑学习还不是简单的给他资料他就能学。电脑，这个高贵的东西，肯定有点小脾气不是，所以你得对他性子才行，他喜欢吃苹果，你非得喂他吃榴莲，他肯定轻则罢学重则 down机啊，榴莲再贵也不行，不对电脑口味。 所以能，咱得找到电脑喜欢啥，给他点啥他才能更好的学习。电脑没长牙，那我就送他两个参数意思意思呗，他不告诉我他喜欢吃啥很是讨厌，我得一个个试，这电脑配置低，性格墨迹，试一次要好长时间，TMD，老子有钱了买个最高配，拿一筐苹果塞他嘴里，让他使劲吃，吃完使劲学。苹果不管用就塞梨，梨再不管用，那我只能破费请他吃个海底捞了。 目前我还没兴致找他口味，所以他现在拉出的便便质量也就那样吧，还凑活能用。]]></content>
      <categories>
        <category>Proactive</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中科院科研项目第二天]]></title>
    <url>%2F2016%2F10%2F03%2F%E4%B8%AD%E7%A7%91%E9%99%A2%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%BA%8C%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[学习乃万恶之首其实我也想度假 一昨天做作业搞到凌晨一点半，所以没有及时发文。 今天作业量小些，先补写一下~ 在计算所上课到下午四点半，下课就不让待着了，待着那里也没wifi。堂堂计算所 竟然不提供全楼 wifi 覆盖，真是说不过去，太掉价了。 而中科院周围跟空城似的，假期真是积极响应党和国家的号召，认认真真休假，找了两家咖啡馆都关门，现在我们下课后的情况就是到处找地方自习蹭 WiFi。 先放一下计算所的照片吧， 内部布局看起来挺大气的，那些座椅在一楼大厅的一侧，在这喝杯咖啡聊聊天还是蛮有韵味的。大门有门禁，负责门禁的是个很帅气的小哥，恩，真挺帅气的。地下一层就乒乓球场地，球台挺好的，空间也够大，本来冲着这点就考虑以后到这找工作了，但是看了他的 wifi 情况还是算了。 二昨天作业算是真正开始接触机器学习了。之前都是使用 MATLAB 对图像进行处理（在此不得不感叹 MATLAB 之强大），但是处理后并不能完全把车牌区域提取出来，经过这种程度地处理电脑还很容易把非车牌区域认为车牌区域，毕竟它也不知道那到底是啥区域，只是判断其颜色，大小，就提取出来了。 要想变得厉害还是得学习！ 机器学习是怎么来的呢？有一群心理变态的人在一起读书学习的时候看着电脑在那无聊的待着，就想：「这电脑怎么能这样呢？要么玩游戏，要么就放点 dirty movie，毒害人类！要么就在那闲着，浪费生命！这可不行，你得学习，不学习不成机器。」于是他们就发明了机器学习，这样电脑也能快乐的陪他们一起学习了。 以上纯属扯淡 用 MATLAB 提取出几块可能是车牌的区域还是不行啊，得让电脑知道哪块才是真正的车牌区域才行。但是人们又懒得一点点教电脑怎么识别哪块才是车牌区域，所以，让电脑自己学去吧！老子才不管你，学不好就摔你！ 学习得有方法，于是那些大（bian）神（tai）善性大发，打算教给电脑一些学习方法，其中一种叫 「SVM（Support Vector Machine）分类器」。 SVM 翻译过来叫支持向量机，他叫“机”，但他不是机器，它属于机器学习中的有监督学习模型。（电脑学个习还得被监督呢？谁监督你啊呸）刚来第二天就要接触高大上的机器学习模型，还得做 ppt 展示？我的表情是这样的 但该学还得学啊，电脑都要学习了，咱不能比不过电脑啊。昨天看资料到12点多，终于感觉理解的差不多了，于是简单做了个 keynote，麻溜睡觉。]]></content>
      <categories>
        <category>Proactive</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中科院科研项目第一天]]></title>
    <url>%2F2016%2F10%2F02%2F%E4%B8%AD%E7%A7%91%E9%99%A2%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[趁着他们都去度假了，看看我们这几天能够做成什么 零昨天从济南千里迢迢终于来到了北京，感谢梦瑶大头曹同学不远万里去车站接我，虽然等了好久= =！ 实习地点在中科院计算所，住处在计算所北边不远处，下了地铁离住处还有1.6km，一路走的好辛苦，在路上见到了中科院的两个研究所，当时我就惊呆了 大名鼎鼎的中科院研究所就长这样？ 赶上我老家危楼了都(╯°□°）╯︵┻━┻中科院怎么这么不注意自己的门面，简单翻新一下，冲刷一遍油漆也不至于这么磕碜，这样看起来给人的感觉简直快穷过我了。还没开课心先凉了一半，不过晚上去计算所踩点发现那边的群楼还是蛮高大上的。今天忘记了拍照片， 一今天上课，五天要做的项目是“车牌识别系统”，工具 MATLAB，所以时间还是很紧张，今天的作业做到晚上10点40，终于才能回住处开始写文章。一起培训的一共只要五个人，我和一个小哥一组，MATLAB 都没怎么用过，所以做作业的时候简直一脸懵逼，发现 Google 就是亲爹啊！ 机器视觉现在用的也是机器学习，最流行的是当前大热的深度学习，我们最终的任务也是给电脑一个训练集，等他好好学习，就认识车牌啦！ 电脑与我们无冤无仇我们却还逼他好好学习，真是人性的沦丧，道德的丢失╭∩╮（︶︿︶）╭∩╮ 任务重也好，课下多学点东西，这次假期结束熟练 MATLAB 应该不成问题了吧。 今天好累，就先写到这]]></content>
      <categories>
        <category>Proactive</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一个科学方法论]]></title>
    <url>%2F2016%2F09%2F20%2F%E4%B8%80%E4%B8%AA%E7%A7%91%E5%AD%A6%E6%96%B9%E6%B3%95%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[“哎，你们单位今年中秋发的啥？”“发的天空二号～” 「天空二号」在中秋节成功发往太空，可喜可贺，也辛苦了工作人员。「天空二号」能够发射成功，离不开控制论的发展与应用。而控制论中的一个重要概念「负反馈」起到了举足轻重的作用。 「负反馈调节」是控制理论中的重要组成部分，而这一思想，通过「它还能用在哪」的思考后，我发现在现实中，不仅有很多事物正在应用它，我们也可以主动用这一科学方法论来指导我们的行动。 什么是负反馈拿今年中秋节发射的天空二号来说吧。天空二号发往目的运行轨道，不是最开始就朝着目标方向发射出去就不管了，而是在发射的过程中，火箭不断地对自己的姿态进行校正，让自己朝正确的方向飞行，而之所以能这样做，就是因为它可以检测自己当前的飞行状态与目的地的关系，由此来校正姿态使自己不会跑偏。这个「检测」—>「校正」的动态过程便是负反馈。 想想老鹰捉小鸡，老鹰在天上飞，看到地上有一只萌萌哒的小鸡，老鹰“嗖”地一下俯冲下去，准确地捕捉到了小鸡。显然，老鹰不是按照事先计划好的路线飞行的，因为受各种随机因素的影响，如果老鹰从空中确定方向和速度等不再更改，那么它是不会抓住小鸡的。 老鹰看到小鸡后，马上估算一下相对位置和大致距离，然后选择一个大致的方向飞向小鸡，在这个过程中，老鹰一直用眼睛盯着小鸡，报告大脑它与小鸡之间的位置关系，由此不断调整飞行方向和速度，最终准确捕捉到小鸡。 我们简单分析一下这个控制系统，老鹰在眼睛盯住小鸡的同时，也注意到了自己的位置，并将两者位置进行比较，图中的“Θ”是一个比较器，经过比较后的信号代表老鹰的位置与小鸡的位置的差值，我们称其为“目标差”，眼睛主要是接收这种目标差信息，并把它传递给大脑。大脑指挥翅膀，从而控制老鹰向目标差小的方向运动，这个过程重复进行，构成了老鹰捉小鸡的连续动作。这里最关键的一点是大脑的决定始终使老鹰的位置向减小目标差的方向改变，控制论中把这类控制过程称为「负反馈调节」。负反馈调节的本质在于设计了一个使目标差不断减小的过程，通过系统不断把自己控制后果与结果相比较，使得目标差在一次一次控制中慢慢减少，最终达到控制的目的。 它是怎么工作的 我们把老鹰的动作看成一系列俯冲动作的连续，每一次俯冲都可以看成对自己位置的控制。老鹰的控制能力是有限的，他不可能一次到达目标，老鹰从高空冲向小鸡，它这一次飞行的能力只能让它达到 B 区域，不能抓住小鸡。如果在一次俯冲后，老鹰用过判断，反馈，马上进行第二次动作，将范围再次缩小到 A 区域，由此往复，精度越来越高，最终使老鹰准确地捉到小鸡。由于实际上老鹰的俯冲动作是连续的，所以我们看起来就像是一步到位。 对我们有何指导意义导弹、火箭、卫星其实都用了这套方法，但这些高大上的东西对我们来说好像并卵。其实我们生活中，我们身边也有好多这个方法的应用。比如我们最熟悉的 app 迭代，为什么一个 app 会一次又一次的更新，其实就是在一个版本发布后，开发者从用户那里得到反馈，反馈指导开发者们对产品进行修改，再发布，再反馈，循环往复，使一个 app 越来越好用。 但我们不是移动 app 开发者，那么我们又能用这套理论做什么呢？ 学新东西，先做起来看知道为什么老师总说“先用起来”，而不是“学起来”吗？这就有「负反馈」的理论在里面。 做起来看，我们做一件没有做过的复杂的事情，总不能把一切安排的周周道道的，客观事物总是在不断变化的，意外的情况也在不断发生，即使我们事先考虑得再周密，也会遇到一些不可预测的麻烦来干扰我们。因此最好的办法就是干起来再说。一边干一边观察，（所以不能闭着眼干，要注意出乎其外，注意反馈）随时修正自己的行动和方法，采取一步一步的办法逼近目标。 我们在最开始学习一个陌生的事物时总是感觉无从下手，就像老鹰盘旋在上空，它还没有发现隐藏在树林里食物。我们要做的就是随便找一个入口下手，可能我们最开始的计划就是从豆瓣中找一本评分最高的书，看上他那么几章，然后我们就发现我们要抓的小鸡了。 不断修改计划 之前我们总是一开始就设定好目标，立马列好计划，然后按着计划去行动，结果总是失败的，或者是失败居多，其实不是我们计划列的不对，不合理，不是我们列计划内容得问题，而是我们列计划方式的问题。 一开始我们就像那个在天上刚刚看到小鸡的老鹰，我们发现了小鸡（设定好了目标），然后找到一个方向朝着小鸡俯冲过去（设定好了计划并去执行），然而如果过程不加调整，你能抓到小鸡的可能性是很小的，风的影响，树叶的干扰，小鸡在某个时间发现了老鹰，到会让你捕捉失败。即你第一次设定的计划是很难达到预想的效果的，有种种随机因素的影响，以及一开始设定计划时也可能会忽略某些因素，都会让你前进的方向并非直至目标。 所以，在行动的过程中要不断观察周围，根据实际情况再对原计划进行改动，从而行成负反馈。这样，我们前进的方向才能越来越朝向我们最开始设定的那个精确点，而不是落到周围圆内的某一点。 以前父母总是教育我们： 定好目标，列好计划，然后严格地按照计划去执行 其实，这样是 TM 绝对不会完成目标的，除非这个目标是小而近的，就像你已经到达 A 区了再捕捉小鸡。 实现任何一个稍微长远一点的目标，或者进入一个十分陌生的领域，我们最开始列的计划是不能一成不变的从头执行到尾的。因为我们对其了解不够，我们的计划不够完美，不够贴合现实，我们需要在前进的过程中获取更多信息来指导修正我们的计划。 只有不断地获得负反馈，不断依靠反馈对自身进行指导，我们才会越来越贴近最终的目标。 想想还能用在哪？ 演讲者观察听众调整演讲 老师观察学生调整上课节奏 打球过程中根据球员状态和对手水平调整战术 ……]]></content>
      <categories>
        <category>Proactive</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《如何高效学习》读书感悟]]></title>
    <url>%2F2016%2F08%2F01%2F%E3%80%8A%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[前言读书如果仅仅是「读」，那是远远不够的。「读」只是简单地「输入」，有时候甚至连「输入」都谈不上吧。「输入」本身没有任何作用，就像如果你有了很多很多钱，只是把它藏起来，压箱底，那这些钱是没有任何作用的，你不去花掉它，不去利用它，这钱甚至连垃圾都不如罢，垃圾还能回收利用呢。（当然，应急钱除外） 有了「输入」之后呢？ 要思考，将信息进行处理。原材料有了，把它加工出来才有价值。「思考」这一步是很累的。有的人读书很快，而且感觉读书很轻松，就是因为他们没有「思考」这一步，读完了，就算完了。感受自动分泌的多巴胺给我们的快感很容易，而主动思考就不简单了。没有「思考」就只能享受生动热烈的内容场面本身带来的快感，无法感悟里面所蕴含的理念、精神。所以，读书应该不是轻松加愉快的，而是很累的一件事。特别是读一本好书，一遍往往不能汲取他的精华，因为人总是会有遗忘，总是会有某些时刻思维不够敏捷，以至于当时无法感悟那部分内容奥妙与精彩。 「思考」之后呢？将浓浓思想如泉涌化为内力，总有一天练就九阳神功？所谓「学以致用」，思考之后当然要「实践」，想想如何使用它，至少，如果觉得很有价值，可以把它分享出来。知识，传播的越广越有价值。另外，在「实践」的过程中，又会有一些事情发生，反馈，使你再次回到「思考」这步。刺激你“开天眼”。 用计算机的方法说，可以是：「输入」-「处理」-「输出」 为什么讲一本书的读后感会扯到我对读书的看法呢？因为这本书讲的学习方法，跟我上面讲的很相似，或者说，他的方法更加细致全面。读这本书，我个人建议慢慢地，思考着读。 在「输入」阶段，就大学生阶段而言吧，大多数大学生的「输入」来源就是教材和网络了。但是大多数大学教材都是自己大学的教授所写，不敢说不好，至少有很大的局限性。所以我建议买一些其他口碑好的教材，这其实就是增加「输入渠道」，让自己获取的信息更加准确，全面，优质。 正题先解释一下书名吧，原文是 『 Learn More Study Less 』，“learn” 和 “study” 都是学习，但 “learn” 强调的是结果，“study” 强调的是过程。所以，这个书名的直译应该是『花更少时间学到更多东西』。而这就产生了效率。 简单讲，这本书就是讲了一些可以帮助我们快速学习概念和相应的方法论。这些概念中有一部分我也确实发现自己应用过，但是没有系统的整理和总结。而其方法论中，有一些我在应用，有一些我从未意识到可以这样，还有一些更高级的方法论，我甚至发现在«生活大爆炸»中的谢尔顿的一些方法就是如此。 一. 思想有时候一本书其实就是讲一句话。比如《把时间当朋友》只讲两个字「积累」，《挤挤都会有的》只讲一个字——「挤」。 我认为这本书其实也可以压缩为两个字：「联系」。并提出了一个概念：「整体性学习」。之前我接触过一个概念，叫「系统性学习」，「系统性学习」强调要把一个学科所学过的知识点上下联系起来，形成一个系统，你的思路可以在这个系统里跑通，但并不强调各个系统之间的关联。 而「整体性学习」思维更加强大，你的程序(思维)不仅要在这一个学科的「系统」里跑，还要跑到其他学科的系统里。正所谓融会贯通。有一种思维又高了一个维度的感觉。 简单说，「整体性学习」也很像分布式网络： 只不过所链接的不再是网络节点，也不是人，而是一个个的概念，知识点。当学习了一个新东西，要想着如何把他和之前懂得的东西建立联系，甚至要跨界跨学科建立联系。这样，在你试图将这些知识联系起来的时候，你不仅加深了对两个系统的理解，有时候还会惊喜的发现自己感悟出了新知识。 作者介绍了三个整体性学习的主要“观点”（总觉这个翻译不太合适）和类比于做饭而产生的五个顺序步骤。 不过最后又增添了第六个步骤——测试。是问自己几个问题。个人感觉颇为收益，每次学习新东西的时候都可以问问自己，现摘录如下 获取阶段的测试——我以前看过或听过这个知识吗？ 理解阶段的测试——我理解知识的含义吗？（至少是字面上的意思。） 拓展阶段的测试——我知道知识从何而来，与哪些知识有关系吗？ 纠错阶段的测试——我删除了那些不恰当的联系吗？我删除了那些错误结论吗？ 应用阶段的测试——我将知识用到实际生活中了吗？ 这本书讲了几种思考方式记忆方式，使用了大量的比喻和类比。其实比喻和类比本身就是很强大的学习方法。 有些方法是我们耳熟能详甚至听腻掉的，比如记公式要知道公式的“所以然”，理解公式里每个字母所代表的含义。以前我总是不以为意，心想这该多累多麻烦啊，那些天才肯定有更好更方便的方法。最终发现，那些天才也是这样罢。但这种方法并不省时啊，相反我要花费很长时间才能理解这个公式的由来和这些fucking字母的含义。我现在认为是因为他们从小如此思考，已经训练出了比我们更快的思考速度。当然了，我相信我们通过长时间使用这种思考方法，也可以加快我们的思考速度和理解速度，一切都可以练出来。 现实版钢铁侠 Elon Musk 也说了，他最赞同的思维模式是 “First principle thinking”。 在TED的采访中，他坦言自己最赞同的思维模式是 “First principle thinking”。 “First principle thinking” 的详细解释和如何运用我会在另外的问题专门回答。简单说来，First principle thinking 就是从事物最基本的公理为出发点来进行推导的思维方式。其对立的方法是 Analogy（类推法），简单说来就是别人或者其他事物如何如何，所以我也要如何如何。 举例说明：“现在我有1万刀的现金想投资股票，我应该买什么股票？” Analogy ：“别人家之前买了这几支股票，赚了不少，或者我旁边有个股票大神也买了这几个股票，赚了，所以我也准备买这几个股票。” First principle thinking：“首先去弄明白股票的原理，看清股票涨跌的本质，然后分析公司的背后价值，接着根据自己的需求，看自己是想长久投价值，然后在A股市场利用趋势捞一波。当然也有可能，在分析过程中发现股票市场的风险大小超过了自己的承受范围，从而放弃投资股票。转而杀入债市或者定期投资等。” 节选自知乎专栏-覃超帝国兴亡史链接点这里 牛人的思维方式总是类似的。想想小时候嫌麻烦懒得思考，幻想有什么奇技淫巧能轻松愉快地记下来，最终不过是死记硬背甚至打小抄真是可笑。哪有什么奇技淫巧，脚踏实地才是王道。 二. 方法作者将信息分类，针对不同类别提出了不同的技巧来记忆。 作者介绍了四个部分的方法： 获取知识 快速阅读 笔记流 联系观点 比喻 内在法 图表法 随意信息的处理 联想法 挂钩法 信息压缩法 知识扩展 实际应用 模型纠错 以项目为基础学习 具体技巧就不大段摘抄了，在此之摘录一些我个人认为很有用的问题或方法。 进行积极阅读时你需要记下： （1）这一节中主要观点是什么？（2）我怎样才能记住主要观点？（3）我要怎样将主要观点拓展开以及应用它。 通过问自己这些问题，回答清这些问题，可以让自己真正地“吃透”文章的内容 怎样进行内在化 （1）明确你要内在化的概念。这是一个生物过程，还是编程中的函数或者是一个数学概念？ （2）从建立脑海中的图像开始。如果你不习惯内在化，可以先试着在纸上画出概念的粗略图，多次尝试后，你就会直接在脑海中想象了。 （3）脑海中的图像是静态的，还是栩栩如生的动态场景？掌握一个行列式需要好几个步骤，所以要让图像动起来，就仿佛在看一部电影一样。 （4）现在开始加上其他感官。试着用手去拿它，去摸它，去打开它，去嗅它的味道，去听它的声音，动用你身体的所有感官，将所有的感觉与运动的图像相联系。 （5）加入更多的感觉或情感。 （6）不断重复和优化图像，直到你一想到它就能很快地回忆起知识。 在«生活大爆炸»中，谢尔顿曾说自己脑中呈现了高清图像，在帮拉杰看观测数据时，他分分钟找到了异常数据，因为质数是粉色的，还有什么气味（具体记不清了）。这不就正是内在化么。这种丰富而又强大的联系极大地帮助了我们记忆与理解问题。 三. 费曼技巧 费曼的一生就是个大写的牛逼，是我最崇拜的现实人物之一。如果想了解这个疯子可以阅读下面的链接： http://www.zhihu.com/question/23916191/answer/26092786 下面是费曼技巧的流程： 第一步：选择要学习的概念首先选好你打算深入理解的概念，拿一张空白纸，在最上方写下概念的名称。 第二步：设想你是老师，正在试图教会一名新生这个知识点这一步你要假想自己费尽口舌让一名毫无这方面知识的学生听懂，并把你的解释记录下来。这一步至关重要，因为在自我解释那些你理解或不理解的知识过程中，你会理解得更好，而原先不明白的地方也得以理清。 第三步：当你感到疑惑时，返回去吧每当你碰到难题感到疑惑时，别急着往下走，学习不是单行道，回过头来，重新阅读参考材料、听讲座或找老师解答，直到你觉得搞懂了为止，然后把解释记到纸上。 第四步：简单化和比喻如果你的解释很啰唆或者艰涩，尽量用简单直白的语言重新表述它，或者找到一个恰当的比喻以更好地理解它。 其实除了「内在化」以外，「教」也是一种很好的学习方法。「教」也可以帮助自己理解问题，更重要的是，在教授的过程中，我们必须对每一个知识点都很熟悉，这时候只是感觉自己理解了是远远不够的，只要理解透彻了，我们才有能力将其清楚地表达出来，让别人明白。不记得是从哪看到的了：真正的大师讲出来的相对论可以让保姆听得懂。自己理解是一个阶段，而能清晰表达出来就是另一个境界了。这也是为什么那些爆满的课堂的老师都是大师级人物的原因。在自己教授自己的过程中，我们很容易发现自己知识的缺失。 费曼技巧中的第二步，有一些 “元编程” 的意味。自己教自己，像极了程序员桌子上的小黄鸭。 其实所谓的「学习效率」，我认为是一个伪概念，就像「阅读速度」一样，其实「阅读速度」的本质是「理解速度」，理解得快，阅读得必然快。不然你说怎么叫 “读的快”？眼珠盯着一个个的字转得快？手指一页一页翻得快？你看了字不一定算阅读，你翻了好多页也不一定叫阅读，只有理解了文字所表达的意思，才算阅读。而「学习效率」的本质我认为应该是「思考速度」。要学懂一个东西我们需要理解，需要用到联想，需要纠错，需要应用。而这些都需要我们极力思考才行。费曼技巧没有提供什么捷径，相反最开始使用我们会发现非常吃力，因为需要我们思考的地方太多。而当我们习惯用这种方法思考后，就会发现 “学习速度” 快了好多。 部分方法摘录书中最后讲了一些方法和理念，一部分我感觉非常好，值得一试，就摘录如下分享给大家。 周/日目标体系周/日目标体系是我知道的最好的对抗延迟的方法，办法很简单： 1.每周周末，列一个清单，包括所有的任务、作业以及你想在下周完成的读书和学习活动。除非在一周内出现意想不到的事情，否则你就有责任完成这个清单，不过也不必超过清单所规定的任务。这样做就把无限的工作分割成在一周内可以完成的子任务。如果这一周特别忙碌，你可能会推迟完成任务。如果这一周很清闲，你可能会提前完成任务。 2.每天晚上，检查周计划，列出每日目标清单。下一步是将每周的工作分配到每一天，你要确保完成每日的工作清单，但是不必超过它。 周/日目标系统有什么好处？（1）可以缓解你作决策的应激。你只需检查清单，就明白是否完成。（2）防止你做一项大任务时耽搁不前，依赖每周和每日目标清单，而不是截止日期，你会有时间紧迫感。（3）帮助分配你的工作量。通过制订计划，你可以将工作适当分配到周和日，不需要考试前熬通宵而前三周一个字不看，你可以细分工作。 提髙注意力阈值。注意力阈值就是指集中完成某项工作的最长时间，超过这个时间，注意力就急剧下降。通过不断接受越来越多的批处理，你可以逐渐提高你的注意力阈值。阈值越高，表示能一次完成的工作量也越大。 现在都流行什么番茄工作法，一次工作25分钟，就好像很厉害了的样子。其实想想高中的时候，一坐一晚上几个小时都能精力高度集中完成任务。只是随着智能手机和互联网的发展，我们经常被一些无关痛痒的消息打断，导致我们难以集中精力，注意力阀值降低。提高自己的注意力阀值，be focus，你最终发现番茄工作法什么的弱爆了。 下面介绍一些你需要知道的保持高效率的建议。（1）是每天学一点还是考前抱佛脚？看起来后者节约时间，实际上前者才是高效率。（2）你的笔记和课本组织得好吗？虽然我喜欢一次学习就搞定它，但是有时候我们还是需要复习，假如学习材料凌乱无序，肯定会浪费时间。材料越有组织，复习起来压力越小。（3）学习时注意力高度集中，还是左顾右盼、三心二意？我学习时从不听音乐、玩手机或看信息，我总是尽量找一个没有人的地方学习。 后记这本书虽然看起来很薄，但是介绍的方法和内容比较多。看的时候感觉很好很有道理值得应用，但实际操作起来容易遗忘和忽略一些部分，所以我建议要时不时地温习。 在书中后半部分有讲 “不要学习”，其实这就体现了翻译的局限性，“learn” 和 “study” 都翻译为 “学习”，而一个强调学习结果，一个强调你在 “学习”(看起来在学习)的过程。在 “不要学习” 这一部分中的 “学习” 指的是 “study”。 工具的产生极大地提高了人类的工作效率和生产力。而此书所介绍概念、方法，就是我们学习过程中可以利用的强大工具。 但是，工具不是一切，不能纠结于工具本身。最重要的还是我们要有「终身学习」的信念 (注意，我不是说观念)。 工具是好的，但不是一切都决定于工具。又想起来《蝙蝠侠五》中忍者大师教给韦恩的那句话：「Skill is nothing, will is everythin.」 学习是一辈子的事情。随着互联网的发展与普及，还有在线支付功能的完善，「知识变现」变得越来越容易。学点东西，开始更加明显地提高我们的生产力。这本书不光提供我们一些方法，也能激起我们学习的热情。 努力学习，追求进步。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用IAR写汇编]]></title>
    <url>%2F2016%2F07%2F26%2F%E7%94%A8IAR%E5%86%99%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[version：IAR7.5创建工程具体参见百度经验前四步。戳→这里。其中，在创建工程时，选择 asm 如图 然后界面变成这样： 删掉它自带的代码，改为下列代码： 12345678910111213141516171819202122232425262728MODULE ?cstartup ;; Forward declaration of sections. SECTION CSTACK:DATA:NOROOT(3) SECTION .intvec:CODE:NOROOT(2) ;EXTERN __iar_program_start PUBLIC __vector_table DATA __vector_table DCD sfe(CSTACK) DCD Reset_Handler ; Reset Handler ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; ;; Default interrupt handlers. ;; THUMB PUBWEAK Reset_Handler SECTION .text:CODE:NOROOT:REORDER(2) Reset_Handler ;LDR R0, =__iar_program_start ;BX R0 ;在这里放置汇编语言测试代码 再建一个文件，main.c，并添加到工程中，参考之前的百度经验链接第六、七步。 在 main.c中写一个 main 函数。 12int mian()&#123;&#125; //内容随意，可空 修改配置对工程点右键，选择“Options”， 然后将各位置的配置修改为同下图： 然后就可以写汇编了~]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
</search>
